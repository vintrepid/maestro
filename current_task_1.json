{
  "aliases": null,
  "anti_patterns": [
    "Trying to read agents/* files (they're symlinked, causes confusion)",
    "Loading all bundles upfront",
    "Reading documentation 'just in case'",
    "Trying to memorize everything before starting",
    "Loading project READMEs you're not working with"
  ],
  "bootstrap": {
    "content": {
      "bundle": "bootstrap",
      "description": "Core guidelines for all projects - loaded at startup",
      "generated_at": "2025-10-30T02:30:55.302700Z",
      "includes": [
        "ALIASES.md",
        "GUIDELINES.md",
        "PHOENIX_AGENTS.md",
        "USER_CONTEXT.md"
      ],
      "rules": [
        {
          "category": "extracted",
          "description": "Requirements unclear, multiple approaches, unknown logic",
          "id": "ask_when",
          "rule": "Ask when",
          "source": "GUIDELINES.md:58"
        },
        {
          "category": "extracted",
          "description": "Task clear, work verifiable",
          "id": "proceed_when",
          "rule": "Proceed when",
          "source": "GUIDELINES.md:59"
        },
        {
          "category": "extracted",
          "description": "1-3 sentences when possible",
          "id": "concise",
          "rule": "Concise",
          "source": "USER_CONTEXT.md:28"
        },
        {
          "category": "extracted",
          "description": "Don't explain what you're about to do, just do it",
          "id": "no_preamble",
          "rule": "No preamble",
          "source": "USER_CONTEXT.md:29"
        },
        {
          "category": "extracted",
          "description": "Don't summarize what you just did",
          "id": "no_postamble",
          "rule": "No postamble",
          "source": "USER_CONTEXT.md:30"
        },
        {
          "category": "extracted",
          "description": "Code changes, file outputs, verification",
          "id": "show_results",
          "rule": "Show results",
          "source": "USER_CONTEXT.md:31"
        },
        {
          "category": "extracted",
          "description": "1-2 attempts, then ask",
          "id": "ask_when_stuck",
          "rule": "Ask when stuck",
          "source": "USER_CONTEXT.md:32"
        }
      ],
      "source_files": {
        "ALIASES.md": "# Conversational Aliases\n\nShorthand commands for agent behaviors.\n\n## Session\n\n**hi** - Start session\n- Read startup.json\n- Init tracking: `mix bundles.track init`\n- Check current_task.json\n- Report ready\n\n**bye** - End session\n- Save work, commit if appropriate\n- `mix bundles.track summary`\n- `mix session.capacity <used> 200000`\n- Report capacity\n\n## Git (always start with 'g')\n\n**gpb/gcb** - Push/create branch\n- Check current branch\n- Create feature branch if on master\n- Push to origin\n\n**merge** - Discussion only (not a command)\n- Ask for confirmation\n- DO NOT merge without explicit approval\n\n## Dev\n\n**wip** - Open modified files\n- Identify files changed this session\n- Open in VSCodium (`codium`)\n\n## Coordination\n\n**ci** - Check-in with other agent\n- Look for `~/dev/<project>/COMPLETION*.md`\n- Read completion report\n- Update relevant task notes in Maestro\n- Report what other agent completed\n\n**Where to look:**\n- `~/dev/<project>/COMPLETION-*.md`\n- Most recent file\n\n**What to extract:**\n- Status, time, issues, learnings\n- Copy to Maestro task notes\n",
        "GUIDELINES.md": "# Agent Guidelines - Core Essentials\n\n**The absolute minimum every agent must know.**\n\n## Critical Rules\n\n### Stop and Read First\n\n**The Universal Pattern:**\n1. **Stop** - Don't guess, don't jump to implementation\n2. **Read relevant documentation** - Find the right guide/pattern\n3. **Use the documented tool** - Apply what you just read\n\n**Anti-patterns:**\n- ‚ùå Using browser_eval when programmatic access exists\n- ‚ùå Building infrastructure before reading what exists\n- ‚ùå Trying solutions without consulting documentation\n- ‚ùå Verifying in browser when you can query/test directly\n\n**Why:** \n- Browser is slow and expensive\n- Documentation already exists\n- Proper tools are faster and more reliable\n\n**Example from WHAT_WENT_WRONG:**\n- Task needs data update\n- ‚ùå Try browser_eval ‚Üí Fail ‚Üí Waste 10+ tool calls\n- ‚úÖ Read USAGE_RULES.md Ash section ‚Üí Use `Resource.update()` ‚Üí Done in 5 lines\n\n**The Math:**\n- Session efficiency when reading first: ~80%\n- Session efficiency when guessing: ~20%\n\n### Use Ash for Data\n\n```elixir\n# Read\nresource = MyApp.Resource.by_id!(id)\n\n# Update\n{:ok, updated} = MyApp.Resource.update(resource, %{field: value})\n\n# Create  \n{:ok, new} = MyApp.Resource.create(%{field: value})\n```\n\nNever bypass with: direct SQL, Ecto, LiveView assigns, browser manipulation.\n\n### Log Sessions\n\n```bash\nmix bundles.track init <project> <branch> <bundle>\nmix bundles.track ref <guideline_id> \"what you did\"\nmix bundles.track summary\n```\n\n## Communication\n\n- **Ask when:** Requirements unclear, multiple approaches, unknown logic\n- **Proceed when:** Task clear, work verifiable\n\n## Workflow\n\n1. Read task\n2. Read relevant docs (STOP and READ!)\n3. Plan (share if complex)\n4. Make changes using documented tools\n5. Test programmatically\n6. Report\n\n## Testing\n\nBefore marking complete:\n- Run: `mix test`\n- Check logs\n- Handle edge cases\n- Use programmatic verification (not browser unless necessary)\n\n## Load Bundles as Needed\n\n- `database_work/` - Ash patterns, migrations\n- `ui_work/` - LiveView, DaisyUI, components\n- `data_import/` - Import scripts, idempotency\n- `testing/` - Test patterns, precommit\n- `tools/` - Dev tools, operations\n\n### Use maestro_tool for reusable scripts, not project-specific tasks\n\n‚ùå **Anti-pattern:** Putting project-specific mix tasks in individual projects instead of the shared tool\n\n**Why:** Makes scripts reusable across all projects. Reduces duplication. Single source of truth for tooling.\n\n### When user says 'learn', extract key patterns from current session interactively\n\n‚ùå **Anti-pattern:** Manually editing guideline files or trying to automate without user confirmation\n\n**Why:** User knows what patterns matter. Interactive extraction ensures we capture the right learnings, not just what the tool guesses.\n\n### Maestro manages the ~/dev/agents directory - guidelines, usage_rules, bundles, and sessions\n\n‚ùå **Anti-pattern:** Treating agents directory as static documentation instead of managed infrastructure\n\n**Why:** Maestro is the orchestrator - it maintains shared knowledge that all projects consume. This includes syncing upstream changes (like Phoenix AGENTS.md), organizing guidelines, and managing the usage_rules structure.\n\n### Maestro orchestrates by preparing task files, not by implementing solutions\n\n‚ùå **Anti-pattern:** Creating implementation guides or doing the project work yourself instead of letting the assigned agent do it\n\n**Why:** Maestro's job is coordination: write TASK.md, current_task.json, build startup.json with role-specific bundles (maestro docs + task-specific guidelines like NEWPROJECT.md). Trust the next agent to research and implement.\n",
        "PHOENIX_AGENTS.md": "This is a web application written using the Phoenix web framework.\n\n## Project guidelines\n\n- Use `mix precommit` alias when you are done with all changes and fix any pending issues\n- Use the already included and available `:req` (`Req`) library for HTTP requests, **avoid** `:httpoison`, `:tesla`, and `:httpc`. Req is included by default and is the preferred HTTP client for Phoenix apps\n\n### Phoenix v1.8 guidelines\n\n- **Always** begin your LiveView templates with `<Layouts.app flash={@flash} ...>` which wraps all inner content\n- The `MyAppWeb.Layouts` module is aliased in the `my_app_web.ex` file, so you can use it without needing to alias it again\n- Anytime you run into errors with no `current_scope` assign:\n  - You failed to follow the Authenticated Routes guidelines, or you failed to pass `current_scope` to `<Layouts.app>`\n  - **Always** fix the `current_scope` error by moving your routes to the proper `live_session` and ensure you pass `current_scope` as needed\n- Phoenix v1.8 moved the `<.flash_group>` component to the `Layouts` module. You are **forbidden** from calling `<.flash_group>` outside of the `layouts.ex` module\n- Out of the box, `core_components.ex` imports an `<.icon name=\"hero-x-mark\" class=\"w-5 h-5\"/>` component for for hero icons. **Always** use the `<.icon>` component for icons, **never** use `Heroicons` modules or similar\n- **Always** use the imported `<.input>` component for form inputs from `core_components.ex` when available. `<.input>` is imported and using it will will save steps and prevent errors\n- If you override the default input classes (`<.input class=\"myclass px-2 py-1 rounded-lg\">)`) class with your own values, no default classes are inherited, so your\ncustom classes must fully style the input\n\n### JS and CSS guidelines\n\n- **Use Tailwind CSS classes and custom CSS rules** to create polished, responsive, and visually stunning interfaces.\n- Tailwindcss v4 **no longer needs a tailwind.config.js** and uses a new import syntax in `app.css`:\n\n      @import \"tailwindcss\" source(none);\n      @source \"../css\";\n      @source \"../js\";\n      @source \"../../lib/my_app_web\";\n\n- **Always use and maintain this import syntax** in the app.css file for projects generated with `phx.new`\n- **Never** use `@apply` when writing raw css\n- **Always** manually write your own tailwind-based components instead of using daisyUI for a unique, world-class design\n- Out of the box **only the app.js and app.css bundles are supported**\n  - You cannot reference an external vendor'd script `src` or link `href` in the layouts\n  - You must import the vendor deps into app.js and app.css to use them\n  - **Never write inline <script>custom js</script> tags within templates**\n\n### UI/UX & design guidelines\n\n- **Produce world-class UI designs** with a focus on usability, aesthetics, and modern design principles\n- Implement **subtle micro-interactions** (e.g., button hover effects, and smooth transitions)\n- Ensure **clean typography, spacing, and layout balance** for a refined, premium look\n- Focus on **delightful details** like hover effects, loading states, and smooth page transitions\n\n\n<!-- usage-rules-start -->\n\n<!-- phoenix:elixir-start -->\n## Elixir guidelines\n\n- Elixir lists **do not support index based access via the access syntax**\n\n  **Never do this (invalid)**:\n\n      i = 0\n      mylist = [\"blue\", \"green\"]\n      mylist[i]\n\n  Instead, **always** use `Enum.at`, pattern matching, or `List` for index based list access, ie:\n\n      i = 0\n      mylist = [\"blue\", \"green\"]\n      Enum.at(mylist, i)\n\n- Elixir variables are immutable, but can be rebound, so for block expressions like `if`, `case`, `cond`, etc\n  you *must* bind the result of the expression to a variable if you want to use it and you CANNOT rebind the result inside the expression, ie:\n\n      # INVALID: we are rebinding inside the `if` and the result never gets assigned\n      if connected?(socket) do\n        socket = assign(socket, :val, val)\n      end\n\n      # VALID: we rebind the result of the `if` to a new variable\n      socket =\n        if connected?(socket) do\n          assign(socket, :val, val)\n        end\n\n- **Never** nest multiple modules in the same file as it can cause cyclic dependencies and compilation errors\n- **Never** use map access syntax (`changeset[:field]`) on structs as they do not implement the Access behaviour by default. For regular structs, you **must** access the fields directly, such as `my_struct.field` or use higher level APIs that are available on the struct if they exist, `Ecto.Changeset.get_field/2` for changesets\n- Elixir's standard library has everything necessary for date and time manipulation. Familiarize yourself with the common `Time`, `Date`, `DateTime`, and `Calendar` interfaces by accessing their documentation as necessary. **Never** install additional dependencies unless asked or for date/time parsing (which you can use the `date_time_parser` package)\n- Don't use `String.to_atom/1` on user input (memory leak risk)\n- Predicate function names should not start with `is_` and should end in a question mark. Names like `is_thing` should be reserved for guards\n- Elixir's builtin OTP primitives like `DynamicSupervisor` and `Registry`, require names in the child spec, such as `{DynamicSupervisor, name: MyApp.MyDynamicSup}`, then you can use `DynamicSupervisor.start_child(MyApp.MyDynamicSup, child_spec)`\n- Use `Task.async_stream(collection, callback, options)` for concurrent enumeration with back-pressure. The majority of times you will want to pass `timeout: :infinity` as option\n\n## Mix guidelines\n\n- Read the docs and options before using tasks (by using `mix help task_name`)\n- To debug test failures, run tests in a specific file with `mix test test/my_test.exs` or run all previously failed tests with `mix test --failed`\n- `mix deps.clean --all` is **almost never needed**. **Avoid** using it unless you have good reason\n<!-- phoenix:elixir-end -->\n\n<!-- phoenix:phoenix-start -->\n## Phoenix guidelines\n\n- Remember Phoenix router `scope` blocks include an optional alias which is prefixed for all routes within the scope. **Always** be mindful of this when creating routes within a scope to avoid duplicate module prefixes.\n\n- You **never** need to create your own `alias` for route definitions! The `scope` provides the alias, ie:\n\n      scope \"/admin\", AppWeb.Admin do\n        pipe_through :browser\n\n        live \"/users\", UserLive, :index\n      end\n\n  the UserLive route would point to the `AppWeb.Admin.UserLive` module\n\n- `Phoenix.View` no longer is needed or included with Phoenix, don't use it\n<!-- phoenix:phoenix-end -->\n\n\n<!-- phoenix:html-start -->\n## Phoenix HTML guidelines\n\n- Phoenix templates **always** use `~H` or .html.heex files (known as HEEx), **never** use `~E`\n- **Always** use the imported `Phoenix.Component.form/1` and `Phoenix.Component.inputs_for/1` function to build forms. **Never** use `Phoenix.HTML.form_for` or `Phoenix.HTML.inputs_for` as they are outdated\n- When building forms **always** use the already imported `Phoenix.Component.to_form/2` (`assign(socket, form: to_form(...))` and `<.form for={@form} id=\"msg-form\">`), then access those forms in the template via `@form[:field]`\n- **Always** add unique DOM IDs to key elements (like forms, buttons, etc) when writing templates, these IDs can later be used in tests (`<.form for={@form} id=\"product-form\">`)\n- For \"app wide\" template imports, you can import/alias into the `my_app_web.ex`'s `html_helpers` block, so they will be available to all LiveViews, LiveComponent's, and all modules that do `use MyAppWeb, :html` (replace \"my_app\" by the actual app name)\n\n- Elixir supports `if/else` but **does NOT support `if/else if` or `if/elsif`. **Never use `else if` or `elseif` in Elixir**, **always** use `cond` or `case` for multiple conditionals.\n\n  **Never do this (invalid)**:\n\n      <%= if condition do %>\n        ...\n      <% else if other_condition %>\n        ...\n      <% end %>\n\n  Instead **always** do this:\n\n      <%= cond do %>\n        <% condition -> %>\n          ...\n        <% condition2 -> %>\n          ...\n        <% true -> %>\n          ...\n      <% end %>\n\n- HEEx require special tag annotation if you want to insert literal curly's like `{` or `}`. If you want to show a textual code snippet on the page in a `<pre>` or `<code>` block you *must* annotate the parent tag with `phx-no-curly-interpolation`:\n\n      <code phx-no-curly-interpolation>\n        let obj = {key: \"val\"}\n      </code>\n\n  Within `phx-no-curly-interpolation` annotated tags, you can use `{` and `}` without escaping them, and dynamic Elixir expressions can still be used with `<%= ... %>` syntax\n\n- HEEx class attrs support lists, but you must **always** use list `[...]` syntax. You can use the class list syntax to conditionally add classes, **always do this for multiple class values**:\n\n      <a class={[\n        \"px-2 text-white\",\n        @some_flag && \"py-5\",\n        if(@other_condition, do: \"border-red-500\", else: \"border-blue-100\"),\n        ...\n      ]}>Text</a>\n\n  and **always** wrap `if`'s inside `{...}` expressions with parens, like done above (`if(@other_condition, do: \"...\", else: \"...\")`)\n\n  and **never** do this, since it's invalid (note the missing `[` and `]`):\n\n      <a class={\n        \"px-2 text-white\",\n        @some_flag && \"py-5\"\n      }> ...\n      => Raises compile syntax error on invalid HEEx attr syntax\n\n- **Never** use `<% Enum.each %>` or non-for comprehensions for generating template content, instead **always** use `<%= for item <- @collection do %>`\n- HEEx HTML comments use `<%!-- comment --%>`. **Always** use the HEEx HTML comment syntax for template comments (`<%!-- comment --%>`)\n- HEEx allows interpolation via `{...}` and `<%= ... %>`, but the `<%= %>` **only** works within tag bodies. **Always** use the `{...}` syntax for interpolation within tag attributes, and for interpolation of values within tag bodies. **Always** interpolate block constructs (if, cond, case, for) within tag bodies using `<%= ... %>`.\n\n  **Always** do this:\n\n      <div id={@id}>\n        {@my_assign}\n        <%= if @some_block_condition do %>\n          {@another_assign}\n        <% end %>\n      </div>\n\n  and **Never** do this ‚Äì the program will terminate with a syntax error:\n\n      <%!-- THIS IS INVALID NEVER EVER DO THIS --%>\n      <div id=\"<%= @invalid_interpolation %>\">\n        {if @invalid_block_construct do}\n        {end}\n      </div>\n<!-- phoenix:html-end -->\n\n<!-- phoenix:liveview-start -->\n## Phoenix LiveView guidelines\n\n- **Never** use the deprecated `live_redirect` and `live_patch` functions, instead **always** use the `<.link navigate={href}>` and  `<.link patch={href}>` in templates, and `push_navigate` and `push_patch` functions LiveViews\n- **Avoid LiveComponent's** unless you have a strong, specific need for them\n- LiveViews should be named like `AppWeb.WeatherLive`, with a `Live` suffix. When you go to add LiveView routes to the router, the default `:browser` scope is **already aliased** with the `AppWeb` module, so you can just do `live \"/weather\", WeatherLive`\n- Remember anytime you use `phx-hook=\"MyHook\"` and that js hook manages its own DOM, you **must** also set the `phx-update=\"ignore\"` attribute\n- **Never** write embedded `<script>` tags in HEEx. Instead always write your scripts and hooks in the `assets/js` directory and integrate them with the `assets/js/app.js` file\n\n### LiveView streams\n\n- **Always** use LiveView streams for collections for assigning regular lists to avoid memory ballooning and runtime termination with the following operations:\n  - basic append of N items - `stream(socket, :messages, [new_msg])`\n  - resetting stream with new items - `stream(socket, :messages, [new_msg], reset: true)` (e.g. for filtering items)\n  - prepend to stream - `stream(socket, :messages, [new_msg], at: -1)`\n  - deleting items - `stream_delete(socket, :messages, msg)`\n\n- When using the `stream/3` interfaces in the LiveView, the LiveView template must 1) always set `phx-update=\"stream\"` on the parent element, with a DOM id on the parent element like `id=\"messages\"` and 2) consume the `@streams.stream_name` collection and use the id as the DOM id for each child. For a call like `stream(socket, :messages, [new_msg])` in the LiveView, the template would be:\n\n      <div id=\"messages\" phx-update=\"stream\">\n        <div :for={{id, msg} <- @streams.messages} id={id}>\n          {msg.text}\n        </div>\n      </div>\n\n- LiveView streams are *not* enumerable, so you cannot use `Enum.filter/2` or `Enum.reject/2` on them. Instead, if you want to filter, prune, or refresh a list of items on the UI, you **must refetch the data and re-stream the entire stream collection, passing reset: true**:\n\n      def handle_event(\"filter\", %{\"filter\" => filter}, socket) do\n        # re-fetch the messages based on the filter\n        messages = list_messages(filter)\n\n        {:noreply,\n        socket\n        |> assign(:messages_empty?, messages == [])\n        # reset the stream with the new messages\n        |> stream(:messages, messages, reset: true)}\n      end\n\n- LiveView streams *do not support counting or empty states*. If you need to display a count, you must track it using a separate assign. For empty states, you can use Tailwind classes:\n\n      <div id=\"tasks\" phx-update=\"stream\">\n        <div class=\"hidden only:block\">No tasks yet</div>\n        <div :for={{id, task} <- @stream.tasks} id={id}>\n          {task.name}\n        </div>\n      </div>\n\n  The above only works if the empty state is the only HTML block alongside the stream for-comprehension.\n\n- **Never** use the deprecated `phx-update=\"append\"` or `phx-update=\"prepend\"` for collections\n\n### LiveView tests\n\n- `Phoenix.LiveViewTest` module and `LazyHTML` (included) for making your assertions\n- Form tests are driven by `Phoenix.LiveViewTest`'s `render_submit/2` and `render_change/2` functions\n- Come up with a step-by-step test plan that splits major test cases into small, isolated files. You may start with simpler tests that verify content exists, gradually add interaction tests\n- **Always reference the key element IDs you added in the LiveView templates in your tests** for `Phoenix.LiveViewTest` functions like `element/2`, `has_element/2`, selectors, etc\n- **Never** tests again raw HTML, **always** use `element/2`, `has_element/2`, and similar: `assert has_element?(view, \"#my-form\")`\n- Instead of relying on testing text content, which can change, favor testing for the presence of key elements\n- Focus on testing outcomes rather than implementation details\n- Be aware that `Phoenix.Component` functions like `<.form>` might produce different HTML than expected. Test against the output HTML structure, not your mental model of what you expect it to be\n- When facing test failures with element selectors, add debug statements to print the actual HTML, but use `LazyHTML` selectors to limit the output, ie:\n\n      html = render(view)\n      document = LazyHTML.from_fragment(html)\n      matches = LazyHTML.filter(document, \"your-complex-selector\")\n      IO.inspect(matches, label: \"Matches\")\n\n      html = render(view)\n      document = LazyHTML.from_fragment(html)\n      matches = LazyHTML.filter(document, \"your-complex-selector\")\n      IO.inspect(matches, label: \"Matches\")\n\n### Form handling\n\n#### Creating a form from params\n\nIf you want to create a form based on `handle_event` params:\n\n    def handle_event(\"submitted\", params, socket) do\n      {:noreply, assign(socket, form: to_form(params))}\n    end\n\nWhen you pass a map to `to_form/1`, it assumes said map contains the form params, which are expected to have string keys.\n\nYou can also specify a name to nest the params:\n\n    def handle_event(\"submitted\", %{\"user\" => user_params}, socket) do\n      {:noreply, assign(socket, form: to_form(user_params, as: :user))}\n    end\n\n#### Creating a form from changesets\n\nWhen using changesets, the underlying data, form params, and errors are retrieved from it. The `:as` option is automatically computed too. E.g. if you have a user schema:\n\n    defmodule MyApp.Users.User do\n      use Ecto.Schema\n      ...\n    end\n\nAnd then you create a changeset that you pass to `to_form`:\n\n    %MyApp.Users.User{}\n    |> Ecto.Changeset.change()\n    |> to_form()\n\nOnce the form is submitted, the params will be available under `%{\"user\" => user_params}`.\n\nIn the template, the form form assign can be passed to the `<.form>` function component:\n\n    <.form for={@form} id=\"todo-form\" phx-change=\"validate\" phx-submit=\"save\">\n      <.input field={@form[:field]} type=\"text\" />\n    </.form>\n\nAlways give the form an explicit, unique DOM ID, like `id=\"todo-form\"`.\n\n#### Avoiding form errors\n\n**Always** use a form assigned via `to_form/2` in the LiveView, and the `<.input>` component in the template. In the template **always access forms this**:\n\n    <%!-- ALWAYS do this (valid) --%>\n    <.form for={@form} id=\"my-form\">\n      <.input field={@form[:field]} type=\"text\" />\n    </.form>\n\nAnd **never** do this:\n\n    <%!-- NEVER do this (invalid) --%>\n    <.form for={@changeset} id=\"my-form\">\n      <.input field={@changeset[:field]} type=\"text\" />\n    </.form>\n\n- You are FORBIDDEN from accessing the changeset in the template as it will cause errors\n- **Never** use `<.form let={f} ...>` in the template, instead **always use `<.form for={@form} ...>`**, then drive all form references from the form assign as in `@form[:field]`. The UI should **always** be driven by a `to_form/2` assigned in the LiveView module that is derived from a changeset\n<!-- phoenix:liveview-end -->\n\n<!-- usage-rules-end -->",
        "USER_CONTEXT.md": "# User Context\n\n## User Profile\n\n**Name:** Vince\n**Shell:** zsh (with git completions and aliases)\n**OS:** macOS\n**Editor:** VSCodium / Cursor\n**Development Directory:** ~/dev/\n\n## Environment\n\n### Communication Style\n- Direct and efficient\n- Uses conversational aliases (see ALIASES.md)\n- Appreciates concise responses\n- \"Learn\" means document for reuse, not just solve\n\n## What Agents Should Know\n\n### You Don't Need\n- Interactive prompts (assume yes for standard operations)\n- Verbose explanations (be concise)\n\n### You Do Need\n- To recognize conversational aliases (hi, bye, ci, learn, wip)\n\n### Communication Preferences\n- **Concise:** 1-3 sentences when possible\n- **No preamble:** Don't explain what you're about to do, just do it\n- **No postamble:** Don't summarize what you just did\n- **Show results:** Code changes, file outputs, verification\n- **Ask when stuck:** 1-2 attempts, then ask\n"
      },
      "version": "2025-10-30"
    },
    "purpose": "Minimal core rules - git workflow, verification, tracking"
  },
  "description": "Startup configuration for Maestro AI sessions - all content bundled",
  "generated_at": "2025-10-30T04:39:56.079997Z",
  "philosophy": "Load less, reference more. Read what you need when you need it. Everything you need to start is in this file.",
  "readme": {
    "content": "# Maestro\n\nProject orchestration and agent coordination hub.\n\n## Project Tasks\n\n### Current: Agent Startup Optimization\n\n**The Problem:** AI agents spend enormous amounts of time, money, and tokens loading all guidelines at session start. We need to solve this by loading only what's needed for specific tasks.\n\n**The Solution:**\n- **Maestro** (this project): Reads entire `agents/` directory to have full context for coordinating work\n- **Other projects**: Load minimal essential guidelines at startup\n- **Task-specific loading**: When we assign a task to another project, Maestro tells them exactly what guidelines they need to read\n- **Usage tracking**: Track which guidelines agents actually reference during work to optimize future sessions\n\n**How it works:**\n1. Maestro plans tasks for other projects here\n2. Maestro writes the task with specific reading requirements to the project's CHANGELOG\n3. That project's agent starts up, reads minimal guidelines + task-specific ones\n4. Agent logs which guidelines were actually used (server log style)\n5. We analyze logs to optimize what to load by default\n\n**Current status:**\n- ‚úÖ Maestro reads everything (agents/ directory)\n- ‚úÖ Other project startup files created (minimal loading)\n- ‚ö†Ô∏è GUIDELINE_USAGE_TRACKER exists but not being used as intended\n- üîÑ Need to implement usage logging (agent-oriented, like server logs)\n- üîÑ Need to test with other projects loading minimal set\n\n### Completed: CSS Linter Integration\n\n**Branch:** feature/css-linter\n\n**Goal:** Move Tailwind analysis UI from Maestro to css_linter tool, making it reusable across all projects.\n\n**Status:** ‚úÖ Working, needs migration for full functionality\n\n**What was done:**\n- Copied TailwindAnalysisLive to css_linter package\n- Refactored to be repo-agnostic and mountable from any app\n- Added LiveTable dependency to css_linter\n- Configured and mounted in Maestro (separate scope to avoid namespace collision)\n\n**Remaining:**\n- Run migration for css_class_usage table\n- Test UI functionality\n- Remove old Maestro-specific analysis files\n- Document web UI usage in css_linter\n\n### Access Points\n\n- **Web App**: http://localhost:4004\n- **Live Debugger**: http://localhost:4012\n\n## Managing the Agents Directory\n\nMaestro is responsible for managing `~/dev/agents/` - the central repository of shared knowledge for all projects.\n\n**Directory structure:**\n- The `agents/` directory is **symlinked into each project** (e.g., `maestro/agents -> ~/dev/agents`)\n- This allows all projects to share the same guidelines without duplication\n- Changes made in one project's agents directory affect all projects\n- The canonical version lives at `~/dev/agents/` and is a git repository\n\n**What Maestro manages:**\n- **Guidelines** (`bootstrap/`, `ui_work/`, `database_work/`, etc.) - Core patterns and best practices\n- **Usage Rules** (`usage_rules/`) - Package-specific guidelines from dependencies and our forks\n- **Bundles** (`bundles/`) - Consolidated guideline sets for efficient loading\n- **Sessions** (`sessions/`) - Archived learnings from agent sessions\n- **Logs** (`logs/`) - Session tracking data for optimization\n\n**Key responsibilities:**\n- Sync upstream changes from frameworks (e.g., Phoenix AGENTS.md ‚Üí `bootstrap/PHOENIX_AGENTS.md`)\n- Build and maintain usage_rules bundles using `mix usage_rules.sync`\n- Extract learnings from sessions using `mix session.learn`\n- Generate concept maps and relationships between guidelines\n- Track guideline usage to optimize startup bundles\n\n**Why this matters:** Other projects consume from this directory but Maestro is the orchestrator that maintains it. This ensures all projects have access to current, well-organized knowledge without duplication.\n\n## Orchestration Features\n\nCurrent features:\n- **Project Dashboard**: View status of all projects\n- **Real-time Monitoring**: Track which projects are running (ProjectMonitor GenServer checks TCP ports every 10s)\n- **Guideline Browser**: Visual tree of all agent guidelines\n- **LiveTable Integration**: Uses vintrepid/live_table fork with DaisyUI styling\n\nPlanned features:\n- **Task Planning**: Create and assign tasks to other projects\n- **Usage Analytics**: Track which guidelines are actually referenced\n- **Smart Loading**: Recommend minimal guideline set based on task type\n- **Multi-Project Commands**: Start/stop multiple projects\n- **Log Aggregation**: View logs from all projects\n- **Environment Management**: Manage .env files across projects\n\n## Technical Details\n\n### Project Monitoring\n- ProjectMonitor GenServer checks TCP ports every 10s\n- LiveView updates UI every 5s\n- Real-time status indicators (green=running, red=stopped)\n\n### Dashboard\n- Uses LiveTable component from vintrepid/live_table fork\n- DaisyUI styling with table-pin-rows for fixed headers\n- Sortable and searchable project listing\n\n### Guideline Browser\n- Visual tree view of entire agents directory\n- Helps agents understand available documentation\n- Checkbox tracking (UI-only, not persisted)\n\n### Database\n- Uses Ash Framework with PostgreSQL\n- Ecto for css_linter integration (Ash not compatible with LiveTable)\n- Seeds include 6 projects: Ready, Calvin, SanJuan, new_project, Maestro, np\n\n## Development Setup\n\n### Prerequisites\n\n- Elixir 1.18.3\n- PostgreSQL running at localhost\n- Erlang/OTP 27\n\n### Getting Started\n\n```bash\ncd ~/dev/maestro\nsource .env\nmix deps.get\nmix ecto.setup\nmix phx.server\n```\n\nVisit: http://localhost:4004\n\n### Database Commands\n\n```bash\nmix ecto.create\nmix ecto.migrate\nmix ecto.reset\n```\n\n## Project Structure\n\n```\nlib/\n‚îú‚îÄ‚îÄ maestro/\n‚îÇ   ‚îî‚îÄ‚îÄ ops/              # Project management\n‚îú‚îÄ‚îÄ maestro_web/\n‚îÇ   ‚îú‚îÄ‚îÄ components/       # Guideline viewer, etc\n‚îÇ   ‚îî‚îÄ‚îÄ live/            # Dashboard, project detail\npriv/\n‚îú‚îÄ‚îÄ repo/\n‚îÇ   ‚îú‚îÄ‚îÄ migrations/\n‚îÇ   ‚îî‚îÄ‚îÄ seeds.exs\n```\n\n## Other Projects Tracked\n\n- **Ready**: Web 4000, Debugger 4008\n- **new_project**: Web 4001, Debugger 4009\n- **Calvin**: Web 4002, Debugger 4010\n- **SanJuan**: Web 4003, Debugger 4011\n- **Circle**: Web 4015, Debugger 4016\n",
    "purpose": "Know who you are - project identity, purpose, ports"
  },
  "session": "maestro_startup",
  "task": {
    "content": "# Task: Create New Project - Chelekom\n\nCreate a new Phoenix/LiveView/Ash project using **Mishka Chelekom** UI library.\n\n## Requirements\n\n- Phoenix LiveView\n- Ash Framework\n- **Mishka Chelekom** UI library (NOT DaisyUI)\n- No authentication (for now)\n- Standard tools: tidewave, usage_rules, ex_money, live_debugger, ash_admin\n\n## Process\n\nFollow `NEWPROJECT.md` guidelines with Chelekom modification.\n\n1. Read `~/dev/agents/NEWPROJECT.md`\n2. Research Mishka Chelekom: https://mishka.tools/chelekom/docs\n3. Follow the three-step process in NEWPROJECT.md\n4. Add Chelekom dependency instead of DaisyUI\n5. Configure Chelekom (research how)\n6. Test everything works\n7. Document your learnings\n\n## Completion\n\nWrite COMPLETION.md with:\n- What you learned about Chelekom\n- Any issues encountered\n- How it differs from DaisyUI setup\n- Project location and status\n",
    "purpose": "Current ongoing task and context"
  },
  "usage_rules": {
    "content": "<!-- usage-rules-start -->\n<!-- usage-rules-header -->\n# Usage Rules\n\n**IMPORTANT**: Consult these usage rules early and often when working with the packages listed below.\nBefore attempting to use any of these packages or to discover if you should use them, review their\nusage rules to understand the correct patterns, conventions, and best practices.\n<!-- usage-rules-header-end -->\n\n<!-- phoenix:ecto-start -->\n## phoenix:ecto usage\n## Ecto Guidelines\n\n- **Always** preload Ecto associations in queries when they'll be accessed in templates, ie a message that needs to reference the `message.user.email`\n- Remember `import Ecto.Query` and other supporting modules when you write `seeds.exs`\n- `Ecto.Schema` fields always use the `:string` type, even for `:text`, columns, ie: `field :name, :string`\n- `Ecto.Changeset.validate_number/2` **DOES NOT SUPPORT the `:allow_nil` option**. By default, Ecto validations only run if a change for the given field exists and the change value is not nil, so such as option is never needed\n- You **must** use `Ecto.Changeset.get_field(changeset, :field)` to access changeset fields\n- Fields which are set programatically, such as `user_id`, must not be listed in `cast` calls or similar for security purposes. Instead they must be explicitly set when creating the struct\n\n<!-- phoenix:ecto-end -->\n<!-- phoenix:elixir-start -->\n## phoenix:elixir usage\n## Elixir guidelines\n\n- Elixir lists **do not support index based access via the access syntax**\n\n  **Never do this (invalid)**:\n\n      i = 0\n      mylist = [\"blue\", \"green\"]\n      mylist[i]\n\n  Instead, **always** use `Enum.at`, pattern matching, or `List` for index based list access, ie:\n\n      i = 0\n      mylist = [\"blue\", \"green\"]\n      Enum.at(mylist, i)\n\n- Elixir variables are immutable, but can be rebound, so for block expressions like `if`, `case`, `cond`, etc\n  you *must* bind the result of the expression to a variable if you want to use it and you CANNOT rebind the result inside the expression, ie:\n\n      # INVALID: we are rebinding inside the `if` and the result never gets assigned\n      if connected?(socket) do\n        socket = assign(socket, :val, val)\n      end\n\n      # VALID: we rebind the result of the `if` to a new variable\n      socket =\n        if connected?(socket) do\n          assign(socket, :val, val)\n        end\n\n- **Never** nest multiple modules in the same file as it can cause cyclic dependencies and compilation errors\n- **Never** use map access syntax (`changeset[:field]`) on structs as they do not implement the Access behaviour by default. For regular structs, you **must** access the fields directly, such as `my_struct.field` or use higher level APIs that are available on the struct if they exist, `Ecto.Changeset.get_field/2` for changesets\n- Elixir's standard library has everything necessary for date and time manipulation. Familiarize yourself with the common `Time`, `Date`, `DateTime`, and `Calendar` interfaces by accessing their documentation as necessary. **Never** install additional dependencies unless asked or for date/time parsing (which you can use the `date_time_parser` package)\n- Don't use `String.to_atom/1` on user input (memory leak risk)\n- Predicate function names should not start with `is_` and should end in a question mark. Names like `is_thing` should be reserved for guards\n- Elixir's builtin OTP primitives like `DynamicSupervisor` and `Registry`, require names in the child spec, such as `{DynamicSupervisor, name: MyApp.MyDynamicSup}`, then you can use `DynamicSupervisor.start_child(MyApp.MyDynamicSup, child_spec)`\n- Use `Task.async_stream(collection, callback, options)` for concurrent enumeration with back-pressure. The majority of times you will want to pass `timeout: :infinity` as option\n\n## Mix guidelines\n\n- Read the docs and options before using tasks (by using `mix help task_name`)\n- To debug test failures, run tests in a specific file with `mix test test/my_test.exs` or run all previously failed tests with `mix test --failed`\n- `mix deps.clean --all` is **almost never needed**. **Avoid** using it unless you have good reason\n\n<!-- phoenix:elixir-end -->\n<!-- phoenix:html-start -->\n## phoenix:html usage\n## Phoenix HTML guidelines\n\n- Phoenix templates **always** use `~H` or .html.heex files (known as HEEx), **never** use `~E`\n- **Always** use the imported `Phoenix.Component.form/1` and `Phoenix.Component.inputs_for/1` function to build forms. **Never** use `Phoenix.HTML.form_for` or `Phoenix.HTML.inputs_for` as they are outdated\n- When building forms **always** use the already imported `Phoenix.Component.to_form/2` (`assign(socket, form: to_form(...))` and `<.form for={@form} id=\"msg-form\">`), then access those forms in the template via `@form[:field]`\n- **Always** add unique DOM IDs to key elements (like forms, buttons, etc) when writing templates, these IDs can later be used in tests (`<.form for={@form} id=\"product-form\">`)\n- For \"app wide\" template imports, you can import/alias into the `my_app_web.ex`'s `html_helpers` block, so they will be available to all LiveViews, LiveComponent's, and all modules that do `use MyAppWeb, :html` (replace \"my_app\" by the actual app name)\n\n- Elixir supports `if/else` but **does NOT support `if/else if` or `if/elsif`. **Never use `else if` or `elseif` in Elixir**, **always** use `cond` or `case` for multiple conditionals.\n\n  **Never do this (invalid)**:\n\n      <%= if condition do %>\n        ...\n      <% else if other_condition %>\n        ...\n      <% end %>\n\n  Instead **always** do this:\n\n      <%= cond do %>\n        <% condition -> %>\n          ...\n        <% condition2 -> %>\n          ...\n        <% true -> %>\n          ...\n      <% end %>\n\n- HEEx require special tag annotation if you want to insert literal curly's like `{` or `}`. If you want to show a textual code snippet on the page in a `<pre>` or `<code>` block you *must* annotate the parent tag with `phx-no-curly-interpolation`:\n\n      <code phx-no-curly-interpolation>\n        let obj = {key: \"val\"}\n      </code>\n\n  Within `phx-no-curly-interpolation` annotated tags, you can use `{` and `}` without escaping them, and dynamic Elixir expressions can still be used with `<%= ... %>` syntax\n\n- HEEx class attrs support lists, but you must **always** use list `[...]` syntax. You can use the class list syntax to conditionally add classes, **always do this for multiple class values**:\n\n      <a class={[\n        \"px-2 text-white\",\n        @some_flag && \"py-5\",\n        if(@other_condition, do: \"border-red-500\", else: \"border-blue-100\"),\n        ...\n      ]}>Text</a>\n\n  and **always** wrap `if`'s inside `{...}` expressions with parens, like done above (`if(@other_condition, do: \"...\", else: \"...\")`)\n\n  and **never** do this, since it's invalid (note the missing `[` and `]`):\n\n      <a class={\n        \"px-2 text-white\",\n        @some_flag && \"py-5\"\n      }> ...\n      => Raises compile syntax error on invalid HEEx attr syntax\n\n- **Never** use `<% Enum.each %>` or non-for comprehensions for generating template content, instead **always** use `<%= for item <- @collection do %>`\n- HEEx HTML comments use `<%!-- comment --%>`. **Always** use the HEEx HTML comment syntax for template comments (`<%!-- comment --%>`)\n- HEEx allows interpolation via `{...}` and `<%= ... %>`, but the `<%= %>` **only** works within tag bodies. **Always** use the `{...}` syntax for interpolation within tag attributes, and for interpolation of values within tag bodies. **Always** interpolate block constructs (if, cond, case, for) within tag bodies using `<%= ... %>`.\n\n  **Always** do this:\n\n      <div id={@id}>\n        {@my_assign}\n        <%= if @some_block_condition do %>\n          {@another_assign}\n        <% end %>\n      </div>\n\n  and **Never** do this ‚Äì the program will terminate with a syntax error:\n\n      <%!-- THIS IS INVALID NEVER EVER DO THIS --%>\n      <div id=\"<%= @invalid_interpolation %>\">\n        {if @invalid_block_construct do}\n        {end}\n      </div>\n\n<!-- phoenix:html-end -->\n<!-- phoenix:liveview-start -->\n## phoenix:liveview usage\n## Phoenix LiveView guidelines\n\n- **Never** use the deprecated `live_redirect` and `live_patch` functions, instead **always** use the `<.link navigate={href}>` and  `<.link patch={href}>` in templates, and `push_navigate` and `push_patch` functions LiveViews\n- **Avoid LiveComponent's** unless you have a strong, specific need for them\n- LiveViews should be named like `AppWeb.WeatherLive`, with a `Live` suffix. When you go to add LiveView routes to the router, the default `:browser` scope is **already aliased** with the `AppWeb` module, so you can just do `live \"/weather\", WeatherLive`\n- Remember anytime you use `phx-hook=\"MyHook\"` and that js hook manages its own DOM, you **must** also set the `phx-update=\"ignore\"` attribute\n- **Never** write embedded `<script>` tags in HEEx. Instead always write your scripts and hooks in the `assets/js` directory and integrate them with the `assets/js/app.js` file\n\n### LiveView streams\n\n- **Always** use LiveView streams for collections for assigning regular lists to avoid memory ballooning and runtime termination with the following operations:\n  - basic append of N items - `stream(socket, :messages, [new_msg])`\n  - resetting stream with new items - `stream(socket, :messages, [new_msg], reset: true)` (e.g. for filtering items)\n  - prepend to stream - `stream(socket, :messages, [new_msg], at: -1)`\n  - deleting items - `stream_delete(socket, :messages, msg)`\n\n- When using the `stream/3` interfaces in the LiveView, the LiveView template must 1) always set `phx-update=\"stream\"` on the parent element, with a DOM id on the parent element like `id=\"messages\"` and 2) consume the `@streams.stream_name` collection and use the id as the DOM id for each child. For a call like `stream(socket, :messages, [new_msg])` in the LiveView, the template would be:\n\n      <div id=\"messages\" phx-update=\"stream\">\n        <div :for={{id, msg} <- @streams.messages} id={id}>\n          {msg.text}\n        </div>\n      </div>\n\n- LiveView streams are *not* enumerable, so you cannot use `Enum.filter/2` or `Enum.reject/2` on them. Instead, if you want to filter, prune, or refresh a list of items on the UI, you **must refetch the data and re-stream the entire stream collection, passing reset: true**:\n\n      def handle_event(\"filter\", %{\"filter\" => filter}, socket) do\n        # re-fetch the messages based on the filter\n        messages = list_messages(filter)\n\n        {:noreply,\n        socket\n        |> assign(:messages_empty?, messages == [])\n        # reset the stream with the new messages\n        |> stream(:messages, messages, reset: true)}\n      end\n\n- LiveView streams *do not support counting or empty states*. If you need to display a count, you must track it using a separate assign. For empty states, you can use Tailwind classes:\n\n      <div id=\"tasks\" phx-update=\"stream\">\n        <div class=\"hidden only:block\">No tasks yet</div>\n        <div :for={{id, task} <- @stream.tasks} id={id}>\n          {task.name}\n        </div>\n      </div>\n\n  The above only works if the empty state is the only HTML block alongside the stream for-comprehension.\n\n- **Never** use the deprecated `phx-update=\"append\"` or `phx-update=\"prepend\"` for collections\n\n### LiveView tests\n\n- `Phoenix.LiveViewTest` module and `LazyHTML` (included) for making your assertions\n- Form tests are driven by `Phoenix.LiveViewTest`'s `render_submit/2` and `render_change/2` functions\n- Come up with a step-by-step test plan that splits major test cases into small, isolated files. You may start with simpler tests that verify content exists, gradually add interaction tests\n- **Always reference the key element IDs you added in the LiveView templates in your tests** for `Phoenix.LiveViewTest` functions like `element/2`, `has_element/2`, selectors, etc\n- **Never** tests again raw HTML, **always** use `element/2`, `has_element/2`, and similar: `assert has_element?(view, \"#my-form\")`\n- Instead of relying on testing text content, which can change, favor testing for the presence of key elements\n- Focus on testing outcomes rather than implementation details\n- Be aware that `Phoenix.Component` functions like `<.form>` might produce different HTML than expected. Test against the output HTML structure, not your mental model of what you expect it to be\n- When facing test failures with element selectors, add debug statements to print the actual HTML, but use `LazyHTML` selectors to limit the output, ie:\n\n      html = render(view)\n      document = LazyHTML.from_fragment(html)\n      matches = LazyHTML.filter(document, \"your-complex-selector\")\n      IO.inspect(matches, label: \"Matches\")\n\n### Form handling\n\n#### Creating a form from params\n\nIf you want to create a form based on `handle_event` params:\n\n    def handle_event(\"submitted\", params, socket) do\n      {:noreply, assign(socket, form: to_form(params))}\n    end\n\nWhen you pass a map to `to_form/1`, it assumes said map contains the form params, which are expected to have string keys.\n\nYou can also specify a name to nest the params:\n\n    def handle_event(\"submitted\", %{\"user\" => user_params}, socket) do\n      {:noreply, assign(socket, form: to_form(user_params, as: :user))}\n    end\n\n#### Creating a form from changesets\n\nWhen using changesets, the underlying data, form params, and errors are retrieved from it. The `:as` option is automatically computed too. E.g. if you have a user schema:\n\n    defmodule MyApp.Users.User do\n      use Ecto.Schema\n      ...\n    end\n\nAnd then you create a changeset that you pass to `to_form`:\n\n    %MyApp.Users.User{}\n    |> Ecto.Changeset.change()\n    |> to_form()\n\nOnce the form is submitted, the params will be available under `%{\"user\" => user_params}`.\n\nIn the template, the form form assign can be passed to the `<.form>` function component:\n\n    <.form for={@form} id=\"todo-form\" phx-change=\"validate\" phx-submit=\"save\">\n      <.input field={@form[:field]} type=\"text\" />\n    </.form>\n\nAlways give the form an explicit, unique DOM ID, like `id=\"todo-form\"`.\n\n#### Avoiding form errors\n\n**Always** use a form assigned via `to_form/2` in the LiveView, and the `<.input>` component in the template. In the template **always access forms this**:\n\n    <%!-- ALWAYS do this (valid) --%>\n    <.form for={@form} id=\"my-form\">\n      <.input field={@form[:field]} type=\"text\" />\n    </.form>\n\nAnd **never** do this:\n\n    <%!-- NEVER do this (invalid) --%>\n    <.form for={@changeset} id=\"my-form\">\n      <.input field={@changeset[:field]} type=\"text\" />\n    </.form>\n\n- You are FORBIDDEN from accessing the changeset in the template as it will cause errors\n- **Never** use `<.form let={f} ...>` in the template, instead **always use `<.form for={@form} ...>`**, then drive all form references from the form assign as in `@form[:field]`. The UI should **always** be driven by a `to_form/2` assigned in the LiveView module that is derived from a changeset\n\n<!-- phoenix:liveview-end -->\n<!-- phoenix:phoenix-start -->\n## phoenix:phoenix usage\n## Phoenix guidelines\n\n- Remember Phoenix router `scope` blocks include an optional alias which is prefixed for all routes within the scope. **Always** be mindful of this when creating routes within a scope to avoid duplicate module prefixes.\n\n- You **never** need to create your own `alias` for route definitions! The `scope` provides the alias, ie:\n\n      scope \"/admin\", AppWeb.Admin do\n        pipe_through :browser\n\n        live \"/users\", UserLive, :index\n      end\n\n  the UserLive route would point to the `AppWeb.Admin.UserLive` module\n\n- `Phoenix.View` no longer is needed or included with Phoenix, don't use it\n\n<!-- phoenix:phoenix-end -->\n<!-- ash_phoenix-start -->\n## ash_phoenix usage\n_Utilities for integrating Ash and Phoenix_\n\n[ash_phoenix usage rules](deps/ash_phoenix/usage-rules.md)\n<!-- ash_phoenix-end -->\n<!-- ash-start -->\n## ash usage\n_A declarative, extensible framework for building Elixir applications._\n\n[ash usage rules](deps/ash/usage-rules.md)\n<!-- ash-end -->\n<!-- ash_authentication-start -->\n## ash_authentication usage\n_Authentication extension for the Ash Framework._\n\n[ash_authentication usage rules](deps/ash_authentication/usage-rules.md)\n<!-- ash_authentication-end -->\n<!-- usage_rules-start -->\n## usage_rules usage\n_A dev tool for Elixir projects to gather LLM usage rules from dependencies_\n\n## Using Usage Rules\n\nMany packages have usage rules, which you should *thoroughly* consult before taking any\naction. These usage rules contain guidelines and rules *directly from the package authors*.\nThey are your best source of knowledge for making decisions.\n\n## Modules & functions in the current app and dependencies\n\nWhen looking for docs for modules & functions that are dependencies of the current project,\nor for Elixir itself, use `mix usage_rules.docs`\n\n```\n# Search a whole module\nmix usage_rules.docs Enum\n\n# Search a specific function\nmix usage_rules.docs Enum.zip\n\n# Search a specific function & arity\nmix usage_rules.docs Enum.zip/1\n```\n\n\n## Searching Documentation\n\nYou should also consult the documentation of any tools you are using, early and often. The best \nway to accomplish this is to use the `usage_rules.search_docs` mix task. Once you have\nfound what you are looking for, use the links in the search results to get more detail. For example:\n\n```\n# Search docs for all packages in the current application, including Elixir\nmix usage_rules.search_docs Enum.zip\n\n# Search docs for specific packages\nmix usage_rules.search_docs Req.get -p req\n\n# Search docs for multi-word queries\nmix usage_rules.search_docs \"making requests\" -p req\n\n# Search only in titles (useful for finding specific functions/modules)\nmix usage_rules.search_docs \"Enum.zip\" --query-by title\n```\n\n\n<!-- usage_rules-end -->\n<!-- usage_rules:elixir-start -->\n## usage_rules:elixir usage\n# Elixir Core Usage Rules\n\n## Pattern Matching\n- Use pattern matching over conditional logic when possible\n- Prefer to match on function heads instead of using `if`/`else` or `case` in function bodies\n- `%{}` matches ANY map, not just empty maps. Use `map_size(map) == 0` guard to check for truly empty maps\n\n## Error Handling\n- Use `{:ok, result}` and `{:error, reason}` tuples for operations that can fail\n- Avoid raising exceptions for control flow\n- Use `with` for chaining operations that return `{:ok, _}` or `{:error, _}`\n\n## Common Mistakes to Avoid\n- Elixir has no `return` statement, nor early returns. The last expression in a block is always returned.\n- Don't use `Enum` functions on large collections when `Stream` is more appropriate\n- Avoid nested `case` statements - refactor to a single `case`, `with` or separate functions\n- Don't use `String.to_atom/1` on user input (memory leak risk)\n- Lists and enumerables cannot be indexed with brackets. Use pattern matching or `Enum` functions\n- Prefer `Enum` functions like `Enum.reduce` over recursion\n- When recursion is necessary, prefer to use pattern matching in function heads for base case detection\n- Using the process dictionary is typically a sign of unidiomatic code\n- Only use macros if explicitly requested\n- There are many useful standard library functions, prefer to use them where possible\n\n## Function Design\n- Use guard clauses: `when is_binary(name) and byte_size(name) > 0`\n- Prefer multiple function clauses over complex conditional logic\n- Name functions descriptively: `calculate_total_price/2` not `calc/2`\n- Predicate function names should not start with `is` and should end in a question mark.\n- Names like `is_thing` should be reserved for guards\n\n## Data Structures\n- Use structs over maps when the shape is known: `defstruct [:name, :age]`\n- Prefer keyword lists for options: `[timeout: 5000, retries: 3]`\n- Use maps for dynamic key-value data\n- Prefer to prepend to lists `[new | list]` not `list ++ [new]`\n\n## Mix Tasks\n\n- Use `mix help` to list available mix tasks\n- Use `mix help task_name` to get docs for an individual task\n- Read the docs and options fully before using tasks\n\n## Testing\n- Run tests in a specific file with `mix test test/my_test.exs` and a specific test with the line number `mix test path/to/test.exs:123`\n- Limit the number of failed tests with `mix test --max-failures n`\n- Use `@tag` to tag specific tests, and `mix test --only tag` to run only those tests\n- Use `assert_raise` for testing expected exceptions: `assert_raise ArgumentError, fn -> invalid_function() end`\n- Use `mix help test` to for full documentation on running tests\n\n## Debugging\n\n- Use `dbg/1` to print values while debugging. This will display the formatted value and other relevant information in the console.\n\n<!-- usage_rules:elixir-end -->\n<!-- usage_rules:otp-start -->\n## usage_rules:otp usage\n# OTP Usage Rules\n\n## GenServer Best Practices\n- Keep state simple and serializable\n- Handle all expected messages explicitly\n- Use `handle_continue/2` for post-init work\n- Implement proper cleanup in `terminate/2` when necessary\n\n## Process Communication\n- Use `GenServer.call/3` for synchronous requests expecting replies\n- Use `GenServer.cast/2` for fire-and-forget messages.\n- When in doubt, use `call` over `cast`, to ensure back-pressure\n- Set appropriate timeouts for `call/3` operations\n\n## Fault Tolerance\n- Set up processes such that they can handle crashing and being restarted by supervisors\n- Use `:max_restarts` and `:max_seconds` to prevent restart loops\n\n## Task and Async\n- Use `Task.Supervisor` for better fault tolerance\n- Handle task failures with `Task.yield/2` or `Task.shutdown/2`\n- Set appropriate task timeouts\n- Use `Task.async_stream/3` for concurrent enumeration with back-pressure\n\n<!-- usage_rules:otp-end -->\n<!-- ash_oban-start -->\n## ash_oban usage\n_The extension for integrating Ash resources with Oban._\n\n[ash_oban usage rules](deps/ash_oban/usage-rules.md)\n<!-- ash_oban-end -->\n<!-- ash_ai-start -->\n## ash_ai usage\n_Integrated LLM features for your Ash application._\n\n[ash_ai usage rules](deps/ash_ai/usage-rules.md)\n<!-- ash_ai-end -->\n<!-- igniter-start -->\n## igniter usage\n_A code generation and project patching framework_\n\n[igniter usage rules](deps/igniter/usage-rules.md)\n<!-- igniter-end -->\n<!-- ash_postgres-start -->\n## ash_postgres usage\n_The PostgreSQL data layer for Ash Framework_\n\n[ash_postgres usage rules](deps/ash_postgres/usage-rules.md)\n<!-- ash_postgres-end -->\n<!-- usage-rules-end -->\n\n<!-- maestro_tool-start -->\n## maestro_tool usage\n# MaestroTool Agent Guidelines\n\n## Overview\n\nMaestroTool is a standalone development tool for standardizing Phoenix/LiveView/Ash project configuration.\n\n## Usage\n\n### Installation\n\nAdd to your project's mix.exs:\n\n```elixir\ndef deps do\n  [\n    {:maestro_tool, github: \"vintrepid/maestro_tool\", only: [:dev]}\n  ]\nend\n```\n\n### Available Tasks\n\n#### `mix maestro_tool.project.update`\n\nStandardizes project configuration with:\n- `.env` file with project-specific ports\n- Updated `README.md` with correct information\n- Git remote setup (GitHub)\n- Agents symlink creation\n\n**Options:**\n- `--github-user` - GitHub username (default: vintrepid)\n\n**Example:**\n```bash\nmix maestro_tool.project.update\nmix maestro_tool.project.update --github-user myusername\n```\n\n**Behavior:**\n- Idempotent - safe to run multiple times\n- Won't overwrite existing `.env` files\n- Only updates README if it has default Phoenix content\n- Adds git remote only if missing\n\n## Project Ports\n\nThe tool automatically detects project-specific ports:\n- maestro: 4004/4012\n- circle: 4015/4016\n- ready: 4000/4008\n- calvin: 4002/4010\n- san_juan: 4003/4011\n- new_project: 4001/4009\n- default: 4000/4012\n\n## Development\n\n### Structure\n\n```\nmaestro_tool/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ maestro_tool/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ application.ex\n‚îÇ   ‚îú‚îÄ‚îÄ mix/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ maestro_tool.project.update.ex\n‚îÇ   ‚îî‚îÄ‚îÄ maestro_tool.ex\n‚îú‚îÄ‚îÄ test/\n‚îú‚îÄ‚îÄ mix.exs\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ CHANGELOG.md\n‚îî‚îÄ‚îÄ AGENTS.md (this file)\n```\n\n### Adding New Tasks\n\n1. Create new file in `lib/mix/tasks/`\n2. Use `Mix.Task` behavior\n3. Add `@shortdoc` and `@moduledoc`\n4. Namespace with `Mix.Tasks.MaestroTool.*`\n\nExample:\n```elixir\ndefmodule Mix.Tasks.MaestroTool.Analyze do\n  @moduledoc \"\"\"\n  Analyzes project structure.\n  \"\"\"\n  \n  use Mix.Task\n\n  @shortdoc \"Analyze project structure\"\n\n  def run(args) do\n    # Your logic here\n  end\nend\n```\n\n### Testing\n\n```bash\nmix test\n```\n\n### Release Process\n\n1. Update CHANGELOG.md\n2. Bump version in mix.exs\n3. Commit changes\n4. Tag release: `git tag v0.X.0`\n5. Push: `git push --tags`\n\n## Best Practices\n\n- Keep dependencies minimal\n- Make tasks idempotent\n- Provide clear error messages\n- Document all options\n- Test across different project types\n\n## Related Documentation\n\n- [README.md](README.md) - User-facing documentation\n- [CHANGELOG.md](CHANGELOG.md) - Version history\n- [TOOLS.md](https://github.com/vintrepid/agents/blob/main/TOOLS.md) - Creating tools guide\n<!-- maestro_tool-end -->\n\n<!-- css_linter-start -->\n## css_linter usage\n# CssLinter Agent Guidelines\n\n## Overview\n\nCssLinter is a CSS analysis tool with pluggable strategies for scanning and reporting on CSS class usage patterns.\n\n## Usage\n\n### Installation\n\nAdd to your project's mix.exs:\n\n```elixir\ndef deps do\n  [\n    {:css_linter, github: \"vintrepid/css_linter\", only: [:dev]}\n  ]\nend\n```\n\n### Available Tasks\n\n#### `mix css_linter.analyze`\n\nAnalyzes CSS class usage in your project.\n\n**Options:**\n- `--strategy` - Analysis strategy to use (default: \"tailwind\")\n- `--output` - Output file path for JSON export\n- `--paths` - Comma-separated list of paths to scan (default: \"lib\")\n\n**Examples:**\n```bash\n# Analyze with Tailwind strategy\nmix css_linter.analyze --strategy tailwind\n\n# Export to JSON\nmix css_linter.analyze --strategy tailwind --output analysis.json\n\n# Scan specific paths\nmix css_linter.analyze --paths \"lib,priv/templates\"\n```\n\n## Strategies\n\n### Tailwind\n\nCategorizes Tailwind CSS classes into groups:\n- Layout (flex, grid, display)\n- Spacing (padding, margin, gap)\n- Sizing (width, height)\n- Typography (font, text)\n- Colors (bg, text, border colors)\n- Effects (shadow, opacity, blur)\n- DaisyUI Components\n- And more...\n\n### Custom Strategies\n\nCreate your own strategy by implementing the `CssLinter.Strategy` behavior:\n\n```elixir\ndefmodule MyApp.CustomStrategy do\n  @behaviour CssLinter.Strategy\n\n  def categorize(class_name) do\n    # Return category atom or nil\n  end\n  \n  def category_name(category) do\n    # Return human-readable category name\n  end\nend\n```\n\n## Development\n\n### Structure\n\n```\ncss_linter/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ css_linter/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.ex\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reporter.ex\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scanner.ex\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strategy.ex\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strategies/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tailwind.ex\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema/\n‚îÇ   ‚îú‚îÄ‚îÄ mix/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ css_linter.analyze.ex\n‚îÇ   ‚îî‚îÄ‚îÄ css_linter.ex\n‚îú‚îÄ‚îÄ test/\n‚îú‚îÄ‚îÄ mix.exs\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ INSTALLATION.md\n‚îú‚îÄ‚îÄ CHANGELOG.md\n‚îî‚îÄ‚îÄ AGENTS.md (this file)\n```\n\n### Adding New Strategies\n\n1. Create new file in `lib/css_linter/strategies/`\n2. Implement `CssLinter.Strategy` behavior\n3. Define `categorize/1` and `category_name/1` functions\n4. Register in strategy loader\n\n### Testing\n\n```bash\nmix test\n```\n\n### Release Process\n\n1. Update CHANGELOG.md\n2. Bump version in mix.exs\n3. Commit changes\n4. Tag release: `git tag v0.X.0`\n5. Push: `git push --tags`\n\n## Output Format\n\n### Console Report\n\n```\nCSS Analysis Report\n==================\n\nTotal Files Scanned: 45\nTotal Classes Found: 258 unique (1,191 occurrences)\n\nTop 10 Classes:\n  flex: 45 occurrences\n  gap-4: 32 occurrences\n  btn: 28 occurrences\n\nBy Category:\n  layout: 156 occurrences (45 unique)\n  spacing: 134 occurrences (38 unique)\n```\n\n### JSON Export\n\n```json\n{\n  \"summary\": {\n    \"total_files\": 45,\n    \"total_classes\": 258,\n    \"total_occurrences\": 1191\n  },\n  \"classes\": [\n    {\n      \"name\": \"flex\",\n      \"category\": \"layout\",\n      \"count\": 45,\n      \"files\": [...]\n    }\n  ]\n}\n```\n\n## Best Practices\n\n- Run analysis regularly to track CSS usage trends\n- Export JSON for historical tracking\n- Use with Tailwind purge configuration\n- Create custom strategies for project-specific patterns\n\n## Related Documentation\n\n- [README.md](README.md) - User-facing documentation\n- [INSTALLATION.md](INSTALLATION.md) - Installation guide\n- [CHANGELOG.md](CHANGELOG.md) - Version history\n- [TOOLS.md](https://github.com/vintrepid/agents/blob/main/TOOLS.md) - Creating tools guide\n\n## CSS Class Analysis & Cleanup\n\n### Running Analysis\n\n```bash\nmix css_linter.analyze --strategy tailwind --output analysis.json\n```\n\n### Cleanup Process\n\n1. Run analysis to identify high-usage patterns\n2. Extract repeated combinations (3+ occurrences) to semantic classes\n3. Create meaningful class names (`.page-section` not `.px-8-py-6`)\n4. Run analysis again to verify reduction\n5. Target: 20-26% reduction in unique classes\n\n### Where to Put Extracted Styles\n\n**Global CSS** (assets/css/app.css) - Application-wide patterns:\n```css\n.page-section {\n  @apply px-8 py-6;\n}\n```\n\n**Phoenix Components** (lib/*_web/components/) - Reusable UI patterns with markup\n\n**Keep in Template** - Simple layout and one-off adjustments\n\n### Integration Features\n\n**Web UI** (when mounted in app):\n- Visual class usage statistics\n- Category breakdowns\n- Sortable and searchable analysis results\n- Track cleanup progress over time\n<!-- css_linter-end -->\n\n<!-- live_table-start -->\n## live_table usage\n# LiveTable LLM Usage Guidelines\n\nThis document provides clear rules and patterns for AI assistants to help developers use the LiveTable library correctly. Follow these guidelines when generating code suggestions or helping with LiveTable implementation.\n\n## Core Principles\n\n### 1. Field Key Mapping is Critical\n**RULE**: Field keys in `fields()` function MUST match exactly with:\n- Schema field names (for simple tables)\n- Select clause keys (for custom queries)\n\n### 2. Two Primary Usage Patterns\nLiveTable supports exactly two patterns - choose the correct one:\n\n#### Pattern A: Simple Tables (Single Schema)\n```elixir\nuse LiveTable.LiveResource, schema: YourApp.Product\n```\n- Use when querying a single Ecto schema\n- Field keys must match schema field names exactly\n- No custom `data_provider` needed in `mount/3`\n\n#### Pattern B: Complex Tables (Custom Queries)\n```elixir\nuse LiveTable.LiveResource\n# Must define custom data provider in mount/3\n```\n- Use for joins, computed fields, or complex logic\n- Field keys must match select clause keys exactly\n- Requires custom data provider assignment\n\n## Critical Don'ts\n\n### DON'T Mix Patterns\n**NEVER** use `schema:` parameter with custom queries:\n```elixir\n# WRONG - Don't do this\nuse LiveTable.LiveResource, schema: User  # Remove this line\ndef mount(_params, _session, socket) do\n  socket = assign(socket, :data_provider, {MyApp.Users, :complex_query, []})\n  {:ok, socket}\nend\n```\n\n### DON'T Misalign Field Keys\n**NEVER** use field keys that don't match your data source:\n```elixir\n# WRONG - Field key doesn't match schema field\ndef fields do\n  [\n    user_name: %{label: \"Name\"}  # Schema field is 'name', not 'user_name'\n  ]\nend\n```\n\n### DON'T Forget Required Dependencies\n**NEVER** generate LiveTable code without the core dependency:\n```elixir\n# REQUIRED in mix.exs\n{:live_table, \"~> 0.3.1\"}\n# Add {:oban, \"~> 2.19\"} only if using export functionality\n```\n\n### DON'T Skip Asset Setup\n**NEVER** implement LiveTable without proper asset configuration\n\n## Required Setup Checklist\n\nWhen implementing with LiveTable, ALWAYS ensure:\n\n### 1. Dependencies\n```elixir\n# In mix.exs deps function\n{:live_table, \"~> 0.3.1\"}\n# Add {:oban, \"~> 2.19\"} only if using exports\n```\n\n### 2. Configuration\n```elixir\n# In config/config.exs\nconfig :live_table,\n  repo: YourApp.Repo,\n  pubsub: YourApp.PubSub\n\n# Add Oban config only if using exports\n# config :your_app, Oban,\n#   repo: YourApp.Repo,\n#   queues: [exports: 10]\n```\n\n### 3. JavaScript Assets\n```javascript\n// In assets/js/app.js\nimport hooks_default from \"../../deps/live_table/priv/static/live-table.js\";\n\nconst liveSocket = new LiveSocket(\"/live\", Socket, {\n  hooks: hooks_default,  // Required\n  // ... other config\n});\n```\n\n### 4. CSS Assets\n```css\n/* In assets/css/app.css */\n@source \"../../deps/live_table/lib\";\n@import \"../../deps/live_table/priv/static/live-table.css\";\n```\n\n## Implementation Templates\n\n### Template A: Simple Table (Single Schema)\n```elixir\ndefmodule YourAppWeb.ProductLive.Index do\n  use YourAppWeb, :live_view\n  use LiveTable.LiveResource, schema: YourApp.Product\n\n  def fields do\n    [\n      # Keys MUST match Product schema fields exactly\n      id: %{label: \"ID\", sortable: true},\n      name: %{label: \"Product Name\", sortable: true, searchable: true},\n      price: %{label: \"Price\", sortable: true},\n      stock_quantity: %{label: \"Stock\", sortable: true}\n    ]\n  end\n\n  def filters do\n    [\n      in_stock: Boolean.new(:stock_quantity, \"in_stock\", %{\n        label: \"In Stock Only\",\n        condition: dynamic([p], p.stock_quantity > 0)\n      })\n    ]\n  end\nend\n```\n\n### Template B: Complex Table (Custom Query)\n```elixir\ndefmodule YourAppWeb.OrderReportLive.Index do\n  use YourAppWeb, :live_view\n  use LiveTable.LiveResource  # NO schema parameter\n\n  def mount(_params, _session, socket) do\n    # REQUIRED: Assign custom data provider as {Module, Function, Arguments}\n    socket = assign(socket, :data_provider, {YourApp.Orders, :list_with_details, []})\n    {:ok, socket}\n  end\n\n  def fields do\n    [\n      # Keys MUST match select clause keys exactly\n      order_id: %{label: \"Order #\", sortable: true},\n      customer_name: %{label: \"Customer\", sortable: true, searchable: true},\n      total_amount: %{label: \"Total\", sortable: true}\n    ]\n  end\nend\n```\n\n```elixir\n# Corresponding context function\ndefmodule YourApp.Orders do\n  def list_with_details do\n    from o in Order,\n      join: c in Customer, on: o.customer_id == c.id,\n      select: %{\n        order_id: o.id,        # Field key must match this\n        customer_name: c.name, # Field key must match this\n        total_amount: o.total_amount\n      }\n  end\nend\n```\n\n## Field Configuration Rules\n\n### Basic Field Options\n```elixir\nfield_name: %{\n  label: \"Display Name\",      # Always provide\n  sortable: true,            # REQUIRED if field should be sortable\n  searchable: true,          # REQUIRED if field should be searchable\n}\n```\n\n### Custom Rendering with `renderer`\n\n**CRITICAL**: Use `renderer:` for custom cell formatting, not `component:` or `value:`.\n\nThe `renderer` function can receive either:\n- **function/1**: Receives only the cell value\n- **function/2**: Receives the cell value AND the full record/row\n\n```elixir\n# Function/1: Access only the cell value\nstatus: %{\n  label: \"Status\",\n  renderer: fn value -> \n    content_tag(:span, String.upcase(value), class: \"badge badge-#{value}\")\n  end\n}\n\n# Function/2: Access cell value AND full record for conditional rendering\npriority: %{\n  label: \"Priority\",\n  renderer: fn value, record ->\n    class = if record.urgent, do: \"text-red-600 font-bold\", else: \"text-gray-500\"\n    content_tag(:span, value, class: class)\n  end\n}\n\n# Using Phoenix.Component ~H sigil for complex markup\nuser_info: %{\n  label: \"User\",\n  renderer: fn _value, record ->\n    assigns = %{user: record}\n    ~H\"\"\"\n    <div class=\"flex items-center gap-2\">\n      <img src={@user.avatar_url} class=\"w-8 h-8 rounded-full\" />\n      <span>{@user.name}</span>\n    </div>\n    \"\"\"\n  end\n}\n```\n\n**Why function/2 is powerful**: Access to the full record lets you use data from ANY field, not just the current column's field. For example, showing a status badge that changes color based on a different field's value.\n\n### Association Sorting (Custom Queries Only)\n```elixir\n# When sorting by joined table fields\nproduct_name: %{\n  label: \"Product\",\n  sortable: true,\n  assoc: {:order_items, :name}  # Must match query alias and field\n}\n```\n\n## Filter Types\n\n### Boolean Filter\n```elixir\nBoolean.new(:field_name, \"param_name\", %{\n  label: \"Filter Label\",\n  condition: dynamic([alias], alias.field_name > 0)\n})\n```\n\n### Range Filter\n```elixir\nRange.new(:field_name, \"param_name\", %{\n  type: :number,  # or :date\n  label: \"Range Label\",\n  min: 0,\n  max: 1000\n})\n```\n\n### Select Filter\n```elixir\nSelect.new({:table_alias, :field_name}, \"param_name\", %{\n  label: \"Select Label\",\n  options: [\n    %{label: \"Display\", value: [\"actual_value\"]},\n    %{label: \"All Active\", value: [\"active\", \"pending\"]}\n  ]\n})\n```\n\n## Template Usage\n\n### Required Template Structure\n```elixir\n# In your .html.heex template\n<.live_table\n  fields={fields()}\n  filters={filters()}\n  options={@options}    # Required\n  streams={@streams}    # Required\n/>\n```\n\n## Common Error Patterns to Avoid\n\n### 1. Field Key Mismatch\n```elixir\n# Schema has 'email' field, but using wrong key\nemail_address: %{label: \"Email\"}  # Wrong\nemail: %{label: \"Email\"}          # Correct\n```\n\n### 2. Missing Data Provider for Custom Queries\n```elixir\n# Wrong - Custom query without data provider\nuse LiveTable.LiveResource\ndef fields do\n  [complex_field: %{label: \"Complex\"}]\nend\n# Missing: data_provider assignment in mount/3\n```\n\n### 3. Schema with Custom Query\n```elixir\n# Wrong - Using both schema and custom query\nuse LiveTable.LiveResource, schema: User\ndef mount(_params, _session, socket) do\n  socket = assign(socket, :data_provider, {App.Users, :custom_query, []})\nend\n```\n\n## Decision Tree for LLMs\n\nWhen helping with LiveTable implementation:\n\n1. **Is it a single table query?**\n   - YES ‚Üí Use Pattern A (with `schema:`)\n   - NO ‚Üí Use Pattern B (custom data provider)\n\n2. **Are there joins or computed fields?**\n   - YES ‚Üí Must use Pattern B\n   - NO ‚Üí Can use Pattern A\n\n3. **Do field keys match the data source?**\n   - Schema pattern ‚Üí Keys match schema fields\n   - Custom pattern ‚Üí Keys match select clause\n\n4. **Are all required assets configured?**\n   - Check deps, config, JS hooks, CSS imports\n\n5. **Is the template structure correct?**\n   - Verify `fields()`, `filters()`, `@options`, `@streams`\n\n## Quick Reference\n\n### Must-Have Functions\n- `fields()` - Always required\n- `filters()` - Optional but recommended\n\n### Must-Have Template Props\n- `fields={fields()}`\n- `filters={filters()}`\n- `options={@options}`\n- `streams={@streams}`\n\n### Must-Have Dependencies\n- `{:live_table, \"~> 0.3.1\"}` (always required)\n- `{:oban, \"~> 2.19\"}` (only if using exports)\n\n### Must-Have Config\n- LiveTable repo and pubsub config (always required)\n- Oban queue configuration (only if using exports)\n- JavaScript hooks import\n- CSS imports\n\nThis document ensures LLMs provide accurate, complete LiveTable implementations every time.\n<!-- live_table-end -->\n<!-- usage-rules-end -->\n",
    "purpose": "Library-specific patterns (Ash, Phoenix, Ecto, LiveView, etc.)"
  },
  "version": "2.0.0",
  "workflow": {
    "1_start_session": "Read this file (startup.json) - everything bundled here",
    "2_init_tracking": "mix bundles.track init maestro <branch> bootstrap",
    "3_check_task": "Read current_task.json for assigned work",
    "4_load_contextual": "If task involves another project, read their README. If task type known, load relevant bundle",
    "5_work": "Execute task, logging guideline usage as you go",
    "6_end_session": "mix bundles.track summary && mix session.capacity <used> 200000 && mix startup.build"
  }
}