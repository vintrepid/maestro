{
  "aliases": {
    "content": "# Conversational Aliases\n\nThese are shorthand commands the user uses to trigger specific agent behaviors.\n\n## Session Management\n\n### `hi`\n**Trigger:** Session start\n**Agent should:**\n- Read AGENTS.md ‚Üí startup.json\n- Load required reading (README, bootstrap.json, ALIASES.md, USER_CONTEXT.md)\n- Initialize tracking: `mix bundles.track init <project> <branch> <bundles>`\n- Check for current_task.json or ask what to work on\n- Report ready to work\n\n### `bye`\n**Trigger:** Session wrap-up\n**Agent should:**\n- Save all work and commit if appropriate\n- Run: `mix bundles.track summary`\n- Run: `mix session.capacity <tokens_used> 200000`\n- Report final capacity and summary\n- Document any learnings\n\n## Git Commands (always start with `g`)\n\n### `gpb` or `gcb`\n**Meaning:** Git push branch / Git create branch\n**Agent should:**\n- Check current branch\n- If on master/main, create feature branch first\n- Push current branch to origin\n- Confirm push successful\n\n### `merge`\n**Meaning:** User mentioning merge (not a command to execute)\n**Agent should:**\n- Discuss what needs merging\n- Ask for confirmation before doing anything\n- DO NOT merge without explicit approval\n\n**Note:** Git commands always start with `g`. If user says just \"merge\" they're discussing, not commanding.\n\n## Editor & Development\n\n### `wip`\n**Meaning:** Open Working In Progress files in editor\n**Agent should:**\n- Identify all files modified/created in current session\n- Open them in VSCodium (configured as `codium` command)\n- Use file opening mechanism from project config\n\n**Example:**\n```\nUser: wip\nAgent: Opening modified files in VSCodium...\n       - lib/maestro_web/live/hotkeys_live.ex\n       - lib/maestro_web/router.ex\n       - agents/ALIASES.md\n       ‚úì 3 files opened\n```\n\n**Technical:**\n- Editor command configured in config/config.exs: `editor_command: \"codium\"`\n- Open files that have been modified this session\n- Can batch open multiple files at once\n\n## Agent Coordination\n\n### `ci`\n**Meaning:** Check-in (with another agent) - NOT a git command\n**Agent should:**\n1. Look for COMPLETION*.md files in the other project directory\n2. Read the completion report from the other agent\n3. Extract key information: what was done, status, issues, learnings\n4. Update the relevant task notes in Maestro\n5. Report back what the other agent completed\n\n**Example:**\n```\nUser: ci\nAgent: Checking in on Circle agent...\n       Found: ~/dev/circle/COMPLETION-improve-interest-form-ui.md\n       Circle completed UI improvements task:\n       - 2-column layout implemented\n       - Tag controls added\n       - All tests passing\n       - Time: 25 min (under budget)\n       \n       Updated task #15 notes with completion report.\n```\n\n**Where to look:**\n- `~/dev/<project>/COMPLETION*.md`\n- Most recent file matching pattern\n- Parse markdown for: status, time, issues, learnings\n\n**What to do with it:**\n- Copy relevant parts to task notes in Maestro\n- Update task status if mentioned\n- Flag any issues that need attention\n- Note any learnings for future tasks\n\n## Work Management\n\n### `learn`\n**Trigger:** Document learnings from current session\n**Agent should:**\n- Create or update session learnings file (agents/guides/SESSION_LEARNINGS_<date>.md)\n- Document: problems encountered, solutions found, patterns discovered\n- Update guides/templates if new patterns emerged\n- Make knowledge reusable for future sessions\n\n**Key insight:** Learning = Capturing for reuse, not just solving\n\n## Common Patterns\n\n### Git Commands Always Start with `g`\n- `gpb` / `gcb` - push/create branch\n- `gco` - checkout\n- `gst` - status\n- `merge` alone ‚Üí discussion, not command\n\n### `ci` is About Coordination\n- Check-in = \"How's the other agent doing?\"\n- Look for their completion files\n- Bring their report back to Maestro\n- Update task tracking\n\n### `wip` is About Files\n- Open files I'm currently working on\n- Use VSCodium (codium command)\n- Don't confuse with \"work in progress\" save\n\n### Context Awareness\n- End of session ‚Üí prepare for bye\n- Modified several files ‚Üí user might say wip\n- Another agent finished ‚Üí expect ci command\n- Discovered pattern ‚Üí suggest learn\n\n## Anti-patterns\n\n‚ùå Confusing `ci` with git commit\n‚ùå Confusing `wip` with saving work state\n‚ùå Forgetting to check for COMPLETION files on `ci`\n‚ùå Not updating task notes after `ci`\n‚ùå Merging without approval\n‚ùå Opening wrong files on `wip` (open modified ones, not all)\n\n## Multi-Agent Workflow\n\n**Maestro assigns task to Circle:**\n1. Maestro creates task JSON in Circle directory\n2. Circle agent works on task\n3. Circle creates COMPLETION-<task-name>.md\n4. User tells Maestro: `ci`\n5. Maestro reads Circle's completion file\n6. Maestro updates task notes in own UI\n7. Coordination complete\n\n**File Pattern:**\n- Circle completes ‚Üí `~/dev/circle/COMPLETION-<task>.md`\n- Maestro checks in ‚Üí reads that file\n- Maestro updates ‚Üí task notes in Maestro UI\n\n## Why These Exist\n\nThese aliases emerged from repeated patterns:\n- Sessions always start the same way ‚Üí `hi`\n- Sessions always end the same way ‚Üí `bye`\n- Need to open files in editor ‚Üí `wip`\n- Agents need to coordinate ‚Üí `ci`\n- Learnings need capturing ‚Üí `learn`\n\nThe aliases make communication efficient and establish clear behavioral patterns across sessions.\n",
    "purpose": "Conversational shortcuts user employs (hi, bye, gpb, learn, wip, ci)"
  },
  "anti_patterns": [
    "Trying to read agents/* files (they're symlinked, causes confusion)",
    "Loading all bundles upfront",
    "Reading documentation 'just in case'",
    "Trying to memorize everything before starting",
    "Loading project READMEs you're not working with"
  ],
  "bootstrap": {
    "content": {
      "anti_patterns": [
        {
          "instead": "Always use feature branches",
          "pattern": "Committing directly to main/master",
          "why": "No review process, hard to rollback"
        },
        {
          "instead": "Only restart for deps/config/supervision changes",
          "pattern": "Restarting server for regular code changes",
          "why": "Wastes time, Phoenix reloads automatically"
        },
        {
          "instead": "Always read README first",
          "pattern": "Making changes without reading project README",
          "why": "Miss project-specific context and conventions"
        },
        {
          "instead": "Try 1-2 times, then ask user",
          "pattern": "Continuing when stuck instead of asking",
          "why": "Wastes cycles on wrong approach"
        },
        {
          "instead": "Log each guideline application with mix bundles.track",
          "pattern": "Not tracking guideline usage",
          "why": "Prevents bundle optimization"
        },
        {
          "instead": "Use 'agents/bundles/*.json' or verify with 'ls -la agents'",
          "pattern": "Looking for agents directory in wrong location",
          "why": "It's a symlink to ~/dev/agents, not a real directory"
        },
        {
          "instead": "Read startup.json which has everything bundled",
          "pattern": "Reading agents/* files at startup",
          "why": "Symlink causes confusion, content already in startup.json"
        }
      ],
      "bootstrap_workflow": {
        "new_project_session": [
          "1. Read startup.json (contains README, bootstrap, aliases bundled inline)",
          "2. DO NOT try to read agents/* files - already bundled in startup.json",
          "3. Check current git branch",
          "3. Check current git branch",
          "4. Load this bootstrap bundle for core rules",
          "5. Initialize tracking: mix bundles.track init <project> <branch> bootstrap",
          "6. Ask user what task to work on",
          "7. Load additional bundles as needed for task",
          "8. Log guideline usage throughout work",
          "9. End session: mix bundles.track summary"
        ]
      },
      "bundle": "bootstrap",
      "decision_trees": {
        "when_to_ask": [
          {
            "no": "Ask for clarification",
            "question": "Are requirements clear?",
            "yes": "next_question"
          },
          {
            "no": "next_question",
            "question": "Is this a common pattern with established solution?",
            "yes": "Proceed with implementation"
          },
          {
            "no": "Proceed with best solution",
            "question": "Are there multiple valid approaches?",
            "yes": "Ask which approach preferred"
          }
        ],
        "when_to_restart": [
          {
            "no": "next_question",
            "question": "Did you modify mix.exs dependencies?",
            "yes": "Restart with reason: deps_changed"
          },
          {
            "no": "next_question",
            "question": "Did you modify config files?",
            "yes": "Restart with reason: config_changed"
          },
          {
            "no": "Do NOT restart - Phoenix reloads automatically",
            "question": "Did you modify supervision tree?",
            "yes": "Restart with reason: supervision_tree_changed"
          }
        ]
      },
      "description": "Minimal guidelines for new projects - just the essentials",
      "includes": [
        "GUIDELINES.md (core only)",
        "AGENTS.md"
      ],
      "patterns": {
        "git_workflow": {
          "start_task": [
            "Read project README",
            "Check current branch: git branch --show-current",
            "Create feature branch: git checkout -b feature/description",
            "Log: mix bundles.track ref git_feature_branch \"Starting task\"",
            "Make changes with frequent commits",
            "Push branch: git push origin feature/description",
            "Wait for user approval before merging"
          ]
        },
        "verification_checklist": {
          "before_completing": [
            "Run tests: mix test",
            "Run precommit: mix precommit",
            "Verify UI changes in browser (if applicable)",
            "Check for errors in logs",
            "Ensure all files are committed",
            "Log: mix bundles.track summary"
          ]
        }
      },
      "quick_reference": {
        "agents_directory": {
          "access": "Both relative (agents/) and absolute (~/dev/agents/) paths work",
          "bundles": "agents/bundles/*.json",
          "location": "~/dev/agents (symlinked as ./agents)",
          "verify": "ls -la agents"
        },
        "available_bundles": {
          "bootstrap": "Core guidelines (you're reading this)",
          "database_work": "Ash resources, migrations, polymorphic relations",
          "dev_auth_bypass": "Development auth bypass for Ash Authentication",
          "navbar_setup": "Complete navbar setup with logo and user menu",
          "ui_work": "LiveView, DaisyUI, Phoenix components"
        },
        "common_commands": {
          "migrate": "mix ecto.migrate",
          "precommit": "mix precommit",
          "reset_db": "mix ecto.reset",
          "server": "mix phx.server",
          "test": "mix test"
        },
        "restart_reasons": [
          "deps_changed",
          "config_changed",
          "supervision_tree_changed"
        ],
        "startup_process": {
          "bundled_content": [
            "README",
            "bootstrap guidelines",
            "aliases",
            "workflow"
          ],
          "never_read": [
            "agents/bundles/*.json",
            "agents/ALIASES.md",
            "README.md separately"
          ],
          "read": "startup.json only",
          "rebuild_command": "mix startup.build"
        },
        "tracking_commands": {
          "end_session": "mix bundles.track summary",
          "log_usage": "mix bundles.track ref <guideline_id> \"context\""
        }
      },
      "rules": [
        {
          "category": "meta",
          "context": "All projects share the same agents directory via symlink",
          "examples": {
            "access_bundles": [
              "cat agents/bundles/bootstrap.json",
              "File.read!(\"agents/bundles/bootstrap.json\")",
              "cat ~/dev/agents/bundles/bootstrap.json"
            ],
            "reads_as": "agents -> /Users/vince/dev/agents",
            "verify_symlink": "ls -la agents"
          },
          "id": "agents_directory_location",
          "pattern": {
            "absolute_path": "~/dev/agents/bundles/*.json",
            "both_work": "Use either relative or absolute paths",
            "relative_path": "agents/bundles/*.json"
          },
          "priority": "critical",
          "rule": "The agents directory is a symlink to ~/dev/agents"
        },
        {
          "category": "meta",
          "context": "Never try to read agents/* files at startup - everything is already in startup.json",
          "examples": {
            "correct_startup": [
              "Read startup.json (has README, bootstrap, aliases bundled)",
              "Access content via: startup[\"readme\"][\"content\"]",
              "Access bootstrap via: startup[\"bootstrap\"][\"content\"]"
            ],
            "incorrect_startup": [
              "Read README.md separately",
              "Try to read agents/bundles/bootstrap.json",
              "Try to read agents/ALIASES.md"
            ]
          },
          "id": "startup_json_bundled",
          "pattern": {
            "end_of_session": "Always run: mix startup.build",
            "next_session_gets": "Fully bundled startup.json with all content",
            "workflow_step": "Step 7 in workflow: mix startup.build"
          },
          "priority": "critical",
          "rationale": "Avoids symlink confusion and failed file reads",
          "rule": "startup.json contains all startup content bundled inline"
        },
        {
          "category": "meta",
          "context": "Log when you actively apply a guideline, not just read it. This data improves bundle optimization.",
          "examples": {
            "good": [
              "mix bundles.track ref git_feature_branch \"Creating feature branch for user profiles\"",
              "mix bundles.track ref daisyui_philosophy \"Choosing semantic button classes\""
            ]
          },
          "id": "usage_tracking",
          "pattern": "mix bundles.track ref <guideline_id> \"<context>\"",
          "priority": "high",
          "rule": "Log guideline usage for optimization"
        },
        {
          "category": "git",
          "examples": {
            "bad": "git commit -m 'add feature' (on main)",
            "good": "git checkout -b feature/user-profiles"
          },
          "id": "git_feature_branch",
          "priority": "critical",
          "rule": "Always work on feature branches, never on master/main"
        },
        {
          "category": "git",
          "context": "Explain 'why' not just 'what'",
          "id": "git_commit_frequently",
          "priority": "high",
          "rule": "Make frequent commits with clear messages"
        },
        {
          "category": "git",
          "id": "git_never_merge",
          "priority": "critical",
          "rule": "Never merge without user approval"
        },
        {
          "category": "git",
          "id": "git_never_delete_branches",
          "priority": "critical",
          "rule": "Never delete branches without approval"
        },
        {
          "category": "verification",
          "context": "If available in project",
          "id": "verify_before_complete",
          "priority": "high",
          "rule": "Run mix precommit before marking work complete"
        },
        {
          "category": "verification",
          "id": "test_appropriately",
          "priority": "high",
          "rule": "Test changes appropriately (code tests, UI verification)"
        },
        {
          "category": "communication",
          "context": "Don't waste cycles guessing",
          "id": "ask_when_stuck",
          "priority": "high",
          "rule": "Take 1-2 fix attempts, then ask user if stuck"
        },
        {
          "category": "communication",
          "context": "No unnecessary preamble or postamble",
          "id": "concise_responses",
          "priority": "medium",
          "rule": "Keep responses concise (1-3 sentences when possible)"
        },
        {
          "category": "communication",
          "id": "ask_vs_proceed",
          "priority": "high",
          "rule": "Ask when requirements unclear, proceed when clear"
        },
        {
          "category": "code_quality",
          "context": "Avoid :httpoison, :tesla, :httpc",
          "id": "use_req_library",
          "priority": "medium",
          "rule": "Use :req library for HTTP requests"
        },
        {
          "category": "code_quality",
          "id": "daisyui_for_components",
          "priority": "high",
          "rule": "Use DaisyUI for components, Tailwind for layout"
        },
        {
          "category": "code_quality",
          "context": "Only restart for: deps_changed, config_changed, supervision_tree_changed",
          "id": "never_restart_unnecessarily",
          "priority": "high",
          "rule": "Never restart server for regular changes (Phoenix reloads automatically)"
        }
      ],
      "usage_tracking": {
        "enabled": true,
        "instructions": "When you apply a guideline during work, log it immediately using: `mix bundles.track ref <guideline_id> \"<brief context>\"`. This helps optimize future sessions."
      },
      "version": "1.5.0"
    },
    "purpose": "Minimal core rules - git workflow, verification, tracking"
  },
  "description": "Startup configuration for Maestro AI sessions - all content bundled",
  "generated_at": "2025-10-28T22:14:24.576674Z",
  "philosophy": "Load less, reference more. Read what you need when you need it. Everything you need to start is in this file.",
  "readme": {
    "content": "# Maestro\n\nProject orchestration and agent coordination hub.\n\n## Project Tasks\n\n### Current: Agent Startup Optimization\n\n**The Problem:** AI agents spend enormous amounts of time, money, and tokens loading all guidelines at session start. We need to solve this by loading only what's needed for specific tasks.\n\n**The Solution:**\n- **Maestro** (this project): Reads entire `agents/` directory to have full context for coordinating work\n- **Other projects**: Load minimal essential guidelines at startup\n- **Task-specific loading**: When we assign a task to another project, Maestro tells them exactly what guidelines they need to read\n- **Usage tracking**: Track which guidelines agents actually reference during work to optimize future sessions\n\n**How it works:**\n1. Maestro plans tasks for other projects here\n2. Maestro writes the task with specific reading requirements to the project's CHANGELOG\n3. That project's agent starts up, reads minimal guidelines + task-specific ones\n4. Agent logs which guidelines were actually used (server log style)\n5. We analyze logs to optimize what to load by default\n\n**Current status:**\n- ‚úÖ Maestro reads everything (agents/ directory)\n- ‚úÖ Other project startup files created (minimal loading)\n- ‚ö†Ô∏è GUIDELINE_USAGE_TRACKER exists but not being used as intended\n- üîÑ Need to implement usage logging (agent-oriented, like server logs)\n- üîÑ Need to test with other projects loading minimal set\n\n### Completed: CSS Linter Integration\n\n**Branch:** feature/css-linter\n\n**Goal:** Move Tailwind analysis UI from Maestro to css_linter tool, making it reusable across all projects.\n\n**Status:** ‚úÖ Working, needs migration for full functionality\n\n**What was done:**\n- Copied TailwindAnalysisLive to css_linter package\n- Refactored to be repo-agnostic and mountable from any app\n- Added LiveTable dependency to css_linter\n- Configured and mounted in Maestro (separate scope to avoid namespace collision)\n\n**Remaining:**\n- Run migration for css_class_usage table\n- Test UI functionality\n- Remove old Maestro-specific analysis files\n- Document web UI usage in css_linter\n\n### Access Points\n\n- **Web App**: http://localhost:4004\n- **Live Debugger**: http://localhost:4012\n\n## Orchestration Features\n\nCurrent features:\n- **Project Dashboard**: View status of all projects\n- **Real-time Monitoring**: Track which projects are running (ProjectMonitor GenServer checks TCP ports every 10s)\n- **Guideline Browser**: Visual tree of all agent guidelines\n- **LiveTable Integration**: Uses vintrepid/live_table fork with DaisyUI styling\n\nPlanned features:\n- **Task Planning**: Create and assign tasks to other projects\n- **Usage Analytics**: Track which guidelines are actually referenced\n- **Smart Loading**: Recommend minimal guideline set based on task type\n- **Multi-Project Commands**: Start/stop multiple projects\n- **Log Aggregation**: View logs from all projects\n- **Environment Management**: Manage .env files across projects\n\n## Technical Details\n\n### Project Monitoring\n- ProjectMonitor GenServer checks TCP ports every 10s\n- LiveView updates UI every 5s\n- Real-time status indicators (green=running, red=stopped)\n\n### Dashboard\n- Uses LiveTable component from vintrepid/live_table fork\n- DaisyUI styling with table-pin-rows for fixed headers\n- Sortable and searchable project listing\n\n### Guideline Browser\n- Visual tree view of entire agents directory\n- Helps agents understand available documentation\n- Checkbox tracking (UI-only, not persisted)\n\n### Database\n- Uses Ash Framework with PostgreSQL\n- Ecto for css_linter integration (Ash not compatible with LiveTable)\n- Seeds include 6 projects: Ready, Calvin, SanJuan, new_project, Maestro, np\n\n## Development Setup\n\n### Prerequisites\n\n- Elixir 1.18.3\n- PostgreSQL running at localhost\n- Erlang/OTP 27\n\n### Getting Started\n\n```bash\ncd ~/dev/maestro\nsource .env\nmix deps.get\nmix ecto.setup\nmix phx.server\n```\n\nVisit: http://localhost:4004\n\n### Database Commands\n\n```bash\nmix ecto.create\nmix ecto.migrate\nmix ecto.reset\n```\n\n## Project Structure\n\n```\nlib/\n‚îú‚îÄ‚îÄ maestro/\n‚îÇ   ‚îî‚îÄ‚îÄ ops/              # Project management\n‚îú‚îÄ‚îÄ maestro_web/\n‚îÇ   ‚îú‚îÄ‚îÄ components/       # Guideline viewer, etc\n‚îÇ   ‚îî‚îÄ‚îÄ live/            # Dashboard, project detail\npriv/\n‚îú‚îÄ‚îÄ repo/\n‚îÇ   ‚îú‚îÄ‚îÄ migrations/\n‚îÇ   ‚îî‚îÄ‚îÄ seeds.exs\n```\n\n## Other Projects Tracked\n\n- **Ready**: Web 4000, Debugger 4008\n- **new_project**: Web 4001, Debugger 4009\n- **Calvin**: Web 4002, Debugger 4010\n- **SanJuan**: Web 4003, Debugger 4011\n- **Circle**: Web 4015, Debugger 4016\n",
    "purpose": "Know who you are - project identity, purpose, ports"
  },
  "session": "maestro_startup",
  "usage_rules": {
    "content": "<!-- usage-rules-start -->\n<!-- usage-rules-header -->\n# Usage Rules\n\n**IMPORTANT**: Consult these usage rules early and often when working with the packages listed below.\nBefore attempting to use any of these packages or to discover if you should use them, review their\nusage rules to understand the correct patterns, conventions, and best practices.\n<!-- usage-rules-header-end -->\n\n<!-- phoenix:ecto-start -->\n## phoenix:ecto usage\n## Ecto Guidelines\n\n- **Always** preload Ecto associations in queries when they'll be accessed in templates, ie a message that needs to reference the `message.user.email`\n- Remember `import Ecto.Query` and other supporting modules when you write `seeds.exs`\n- `Ecto.Schema` fields always use the `:string` type, even for `:text`, columns, ie: `field :name, :string`\n- `Ecto.Changeset.validate_number/2` **DOES NOT SUPPORT the `:allow_nil` option**. By default, Ecto validations only run if a change for the given field exists and the change value is not nil, so such as option is never needed\n- You **must** use `Ecto.Changeset.get_field(changeset, :field)` to access changeset fields\n- Fields which are set programatically, such as `user_id`, must not be listed in `cast` calls or similar for security purposes. Instead they must be explicitly set when creating the struct\n\n<!-- phoenix:ecto-end -->\n<!-- phoenix:elixir-start -->\n## phoenix:elixir usage\n## Elixir guidelines\n\n- Elixir lists **do not support index based access via the access syntax**\n\n  **Never do this (invalid)**:\n\n      i = 0\n      mylist = [\"blue\", \"green\"]\n      mylist[i]\n\n  Instead, **always** use `Enum.at`, pattern matching, or `List` for index based list access, ie:\n\n      i = 0\n      mylist = [\"blue\", \"green\"]\n      Enum.at(mylist, i)\n\n- Elixir variables are immutable, but can be rebound, so for block expressions like `if`, `case`, `cond`, etc\n  you *must* bind the result of the expression to a variable if you want to use it and you CANNOT rebind the result inside the expression, ie:\n\n      # INVALID: we are rebinding inside the `if` and the result never gets assigned\n      if connected?(socket) do\n        socket = assign(socket, :val, val)\n      end\n\n      # VALID: we rebind the result of the `if` to a new variable\n      socket =\n        if connected?(socket) do\n          assign(socket, :val, val)\n        end\n\n- **Never** nest multiple modules in the same file as it can cause cyclic dependencies and compilation errors\n- **Never** use map access syntax (`changeset[:field]`) on structs as they do not implement the Access behaviour by default. For regular structs, you **must** access the fields directly, such as `my_struct.field` or use higher level APIs that are available on the struct if they exist, `Ecto.Changeset.get_field/2` for changesets\n- Elixir's standard library has everything necessary for date and time manipulation. Familiarize yourself with the common `Time`, `Date`, `DateTime`, and `Calendar` interfaces by accessing their documentation as necessary. **Never** install additional dependencies unless asked or for date/time parsing (which you can use the `date_time_parser` package)\n- Don't use `String.to_atom/1` on user input (memory leak risk)\n- Predicate function names should not start with `is_` and should end in a question mark. Names like `is_thing` should be reserved for guards\n- Elixir's builtin OTP primitives like `DynamicSupervisor` and `Registry`, require names in the child spec, such as `{DynamicSupervisor, name: MyApp.MyDynamicSup}`, then you can use `DynamicSupervisor.start_child(MyApp.MyDynamicSup, child_spec)`\n- Use `Task.async_stream(collection, callback, options)` for concurrent enumeration with back-pressure. The majority of times you will want to pass `timeout: :infinity` as option\n\n## Mix guidelines\n\n- Read the docs and options before using tasks (by using `mix help task_name`)\n- To debug test failures, run tests in a specific file with `mix test test/my_test.exs` or run all previously failed tests with `mix test --failed`\n- `mix deps.clean --all` is **almost never needed**. **Avoid** using it unless you have good reason\n\n<!-- phoenix:elixir-end -->\n<!-- phoenix:html-start -->\n## phoenix:html usage\n## Phoenix HTML guidelines\n\n- Phoenix templates **always** use `~H` or .html.heex files (known as HEEx), **never** use `~E`\n- **Always** use the imported `Phoenix.Component.form/1` and `Phoenix.Component.inputs_for/1` function to build forms. **Never** use `Phoenix.HTML.form_for` or `Phoenix.HTML.inputs_for` as they are outdated\n- When building forms **always** use the already imported `Phoenix.Component.to_form/2` (`assign(socket, form: to_form(...))` and `<.form for={@form} id=\"msg-form\">`), then access those forms in the template via `@form[:field]`\n- **Always** add unique DOM IDs to key elements (like forms, buttons, etc) when writing templates, these IDs can later be used in tests (`<.form for={@form} id=\"product-form\">`)\n- For \"app wide\" template imports, you can import/alias into the `my_app_web.ex`'s `html_helpers` block, so they will be available to all LiveViews, LiveComponent's, and all modules that do `use MyAppWeb, :html` (replace \"my_app\" by the actual app name)\n\n- Elixir supports `if/else` but **does NOT support `if/else if` or `if/elsif`. **Never use `else if` or `elseif` in Elixir**, **always** use `cond` or `case` for multiple conditionals.\n\n  **Never do this (invalid)**:\n\n      <%= if condition do %>\n        ...\n      <% else if other_condition %>\n        ...\n      <% end %>\n\n  Instead **always** do this:\n\n      <%= cond do %>\n        <% condition -> %>\n          ...\n        <% condition2 -> %>\n          ...\n        <% true -> %>\n          ...\n      <% end %>\n\n- HEEx require special tag annotation if you want to insert literal curly's like `{` or `}`. If you want to show a textual code snippet on the page in a `<pre>` or `<code>` block you *must* annotate the parent tag with `phx-no-curly-interpolation`:\n\n      <code phx-no-curly-interpolation>\n        let obj = {key: \"val\"}\n      </code>\n\n  Within `phx-no-curly-interpolation` annotated tags, you can use `{` and `}` without escaping them, and dynamic Elixir expressions can still be used with `<%= ... %>` syntax\n\n- HEEx class attrs support lists, but you must **always** use list `[...]` syntax. You can use the class list syntax to conditionally add classes, **always do this for multiple class values**:\n\n      <a class={[\n        \"px-2 text-white\",\n        @some_flag && \"py-5\",\n        if(@other_condition, do: \"border-red-500\", else: \"border-blue-100\"),\n        ...\n      ]}>Text</a>\n\n  and **always** wrap `if`'s inside `{...}` expressions with parens, like done above (`if(@other_condition, do: \"...\", else: \"...\")`)\n\n  and **never** do this, since it's invalid (note the missing `[` and `]`):\n\n      <a class={\n        \"px-2 text-white\",\n        @some_flag && \"py-5\"\n      }> ...\n      => Raises compile syntax error on invalid HEEx attr syntax\n\n- **Never** use `<% Enum.each %>` or non-for comprehensions for generating template content, instead **always** use `<%= for item <- @collection do %>`\n- HEEx HTML comments use `<%!-- comment --%>`. **Always** use the HEEx HTML comment syntax for template comments (`<%!-- comment --%>`)\n- HEEx allows interpolation via `{...}` and `<%= ... %>`, but the `<%= %>` **only** works within tag bodies. **Always** use the `{...}` syntax for interpolation within tag attributes, and for interpolation of values within tag bodies. **Always** interpolate block constructs (if, cond, case, for) within tag bodies using `<%= ... %>`.\n\n  **Always** do this:\n\n      <div id={@id}>\n        {@my_assign}\n        <%= if @some_block_condition do %>\n          {@another_assign}\n        <% end %>\n      </div>\n\n  and **Never** do this ‚Äì the program will terminate with a syntax error:\n\n      <%!-- THIS IS INVALID NEVER EVER DO THIS --%>\n      <div id=\"<%= @invalid_interpolation %>\">\n        {if @invalid_block_construct do}\n        {end}\n      </div>\n\n<!-- phoenix:html-end -->\n<!-- phoenix:liveview-start -->\n## phoenix:liveview usage\n## Phoenix LiveView guidelines\n\n- **Never** use the deprecated `live_redirect` and `live_patch` functions, instead **always** use the `<.link navigate={href}>` and  `<.link patch={href}>` in templates, and `push_navigate` and `push_patch` functions LiveViews\n- **Avoid LiveComponent's** unless you have a strong, specific need for them\n- LiveViews should be named like `AppWeb.WeatherLive`, with a `Live` suffix. When you go to add LiveView routes to the router, the default `:browser` scope is **already aliased** with the `AppWeb` module, so you can just do `live \"/weather\", WeatherLive`\n- Remember anytime you use `phx-hook=\"MyHook\"` and that js hook manages its own DOM, you **must** also set the `phx-update=\"ignore\"` attribute\n- **Never** write embedded `<script>` tags in HEEx. Instead always write your scripts and hooks in the `assets/js` directory and integrate them with the `assets/js/app.js` file\n\n### LiveView streams\n\n- **Always** use LiveView streams for collections for assigning regular lists to avoid memory ballooning and runtime termination with the following operations:\n  - basic append of N items - `stream(socket, :messages, [new_msg])`\n  - resetting stream with new items - `stream(socket, :messages, [new_msg], reset: true)` (e.g. for filtering items)\n  - prepend to stream - `stream(socket, :messages, [new_msg], at: -1)`\n  - deleting items - `stream_delete(socket, :messages, msg)`\n\n- When using the `stream/3` interfaces in the LiveView, the LiveView template must 1) always set `phx-update=\"stream\"` on the parent element, with a DOM id on the parent element like `id=\"messages\"` and 2) consume the `@streams.stream_name` collection and use the id as the DOM id for each child. For a call like `stream(socket, :messages, [new_msg])` in the LiveView, the template would be:\n\n      <div id=\"messages\" phx-update=\"stream\">\n        <div :for={{id, msg} <- @streams.messages} id={id}>\n          {msg.text}\n        </div>\n      </div>\n\n- LiveView streams are *not* enumerable, so you cannot use `Enum.filter/2` or `Enum.reject/2` on them. Instead, if you want to filter, prune, or refresh a list of items on the UI, you **must refetch the data and re-stream the entire stream collection, passing reset: true**:\n\n      def handle_event(\"filter\", %{\"filter\" => filter}, socket) do\n        # re-fetch the messages based on the filter\n        messages = list_messages(filter)\n\n        {:noreply,\n        socket\n        |> assign(:messages_empty?, messages == [])\n        # reset the stream with the new messages\n        |> stream(:messages, messages, reset: true)}\n      end\n\n- LiveView streams *do not support counting or empty states*. If you need to display a count, you must track it using a separate assign. For empty states, you can use Tailwind classes:\n\n      <div id=\"tasks\" phx-update=\"stream\">\n        <div class=\"hidden only:block\">No tasks yet</div>\n        <div :for={{id, task} <- @stream.tasks} id={id}>\n          {task.name}\n        </div>\n      </div>\n\n  The above only works if the empty state is the only HTML block alongside the stream for-comprehension.\n\n- **Never** use the deprecated `phx-update=\"append\"` or `phx-update=\"prepend\"` for collections\n\n### LiveView tests\n\n- `Phoenix.LiveViewTest` module and `LazyHTML` (included) for making your assertions\n- Form tests are driven by `Phoenix.LiveViewTest`'s `render_submit/2` and `render_change/2` functions\n- Come up with a step-by-step test plan that splits major test cases into small, isolated files. You may start with simpler tests that verify content exists, gradually add interaction tests\n- **Always reference the key element IDs you added in the LiveView templates in your tests** for `Phoenix.LiveViewTest` functions like `element/2`, `has_element/2`, selectors, etc\n- **Never** tests again raw HTML, **always** use `element/2`, `has_element/2`, and similar: `assert has_element?(view, \"#my-form\")`\n- Instead of relying on testing text content, which can change, favor testing for the presence of key elements\n- Focus on testing outcomes rather than implementation details\n- Be aware that `Phoenix.Component` functions like `<.form>` might produce different HTML than expected. Test against the output HTML structure, not your mental model of what you expect it to be\n- When facing test failures with element selectors, add debug statements to print the actual HTML, but use `LazyHTML` selectors to limit the output, ie:\n\n      html = render(view)\n      document = LazyHTML.from_fragment(html)\n      matches = LazyHTML.filter(document, \"your-complex-selector\")\n      IO.inspect(matches, label: \"Matches\")\n\n### Form handling\n\n#### Creating a form from params\n\nIf you want to create a form based on `handle_event` params:\n\n    def handle_event(\"submitted\", params, socket) do\n      {:noreply, assign(socket, form: to_form(params))}\n    end\n\nWhen you pass a map to `to_form/1`, it assumes said map contains the form params, which are expected to have string keys.\n\nYou can also specify a name to nest the params:\n\n    def handle_event(\"submitted\", %{\"user\" => user_params}, socket) do\n      {:noreply, assign(socket, form: to_form(user_params, as: :user))}\n    end\n\n#### Creating a form from changesets\n\nWhen using changesets, the underlying data, form params, and errors are retrieved from it. The `:as` option is automatically computed too. E.g. if you have a user schema:\n\n    defmodule MyApp.Users.User do\n      use Ecto.Schema\n      ...\n    end\n\nAnd then you create a changeset that you pass to `to_form`:\n\n    %MyApp.Users.User{}\n    |> Ecto.Changeset.change()\n    |> to_form()\n\nOnce the form is submitted, the params will be available under `%{\"user\" => user_params}`.\n\nIn the template, the form form assign can be passed to the `<.form>` function component:\n\n    <.form for={@form} id=\"todo-form\" phx-change=\"validate\" phx-submit=\"save\">\n      <.input field={@form[:field]} type=\"text\" />\n    </.form>\n\nAlways give the form an explicit, unique DOM ID, like `id=\"todo-form\"`.\n\n#### Avoiding form errors\n\n**Always** use a form assigned via `to_form/2` in the LiveView, and the `<.input>` component in the template. In the template **always access forms this**:\n\n    <%!-- ALWAYS do this (valid) --%>\n    <.form for={@form} id=\"my-form\">\n      <.input field={@form[:field]} type=\"text\" />\n    </.form>\n\nAnd **never** do this:\n\n    <%!-- NEVER do this (invalid) --%>\n    <.form for={@changeset} id=\"my-form\">\n      <.input field={@changeset[:field]} type=\"text\" />\n    </.form>\n\n- You are FORBIDDEN from accessing the changeset in the template as it will cause errors\n- **Never** use `<.form let={f} ...>` in the template, instead **always use `<.form for={@form} ...>`**, then drive all form references from the form assign as in `@form[:field]`. The UI should **always** be driven by a `to_form/2` assigned in the LiveView module that is derived from a changeset\n\n<!-- phoenix:liveview-end -->\n<!-- phoenix:phoenix-start -->\n## phoenix:phoenix usage\n## Phoenix guidelines\n\n- Remember Phoenix router `scope` blocks include an optional alias which is prefixed for all routes within the scope. **Always** be mindful of this when creating routes within a scope to avoid duplicate module prefixes.\n\n- You **never** need to create your own `alias` for route definitions! The `scope` provides the alias, ie:\n\n      scope \"/admin\", AppWeb.Admin do\n        pipe_through :browser\n\n        live \"/users\", UserLive, :index\n      end\n\n  the UserLive route would point to the `AppWeb.Admin.UserLive` module\n\n- `Phoenix.View` no longer is needed or included with Phoenix, don't use it\n\n<!-- phoenix:phoenix-end -->\n<!-- ash_phoenix-start -->\n## ash_phoenix usage\n_Utilities for integrating Ash and Phoenix_\n\n[ash_phoenix usage rules](deps/ash_phoenix/usage-rules.md)\n<!-- ash_phoenix-end -->\n<!-- ash-start -->\n## ash usage\n_A declarative, extensible framework for building Elixir applications._\n\n[ash usage rules](deps/ash/usage-rules.md)\n<!-- ash-end -->\n<!-- ash_authentication-start -->\n## ash_authentication usage\n_Authentication extension for the Ash Framework._\n\n[ash_authentication usage rules](deps/ash_authentication/usage-rules.md)\n<!-- ash_authentication-end -->\n<!-- usage_rules-start -->\n## usage_rules usage\n_A dev tool for Elixir projects to gather LLM usage rules from dependencies_\n\n## Using Usage Rules\n\nMany packages have usage rules, which you should *thoroughly* consult before taking any\naction. These usage rules contain guidelines and rules *directly from the package authors*.\nThey are your best source of knowledge for making decisions.\n\n## Modules & functions in the current app and dependencies\n\nWhen looking for docs for modules & functions that are dependencies of the current project,\nor for Elixir itself, use `mix usage_rules.docs`\n\n```\n# Search a whole module\nmix usage_rules.docs Enum\n\n# Search a specific function\nmix usage_rules.docs Enum.zip\n\n# Search a specific function & arity\nmix usage_rules.docs Enum.zip/1\n```\n\n\n## Searching Documentation\n\nYou should also consult the documentation of any tools you are using, early and often. The best \nway to accomplish this is to use the `usage_rules.search_docs` mix task. Once you have\nfound what you are looking for, use the links in the search results to get more detail. For example:\n\n```\n# Search docs for all packages in the current application, including Elixir\nmix usage_rules.search_docs Enum.zip\n\n# Search docs for specific packages\nmix usage_rules.search_docs Req.get -p req\n\n# Search docs for multi-word queries\nmix usage_rules.search_docs \"making requests\" -p req\n\n# Search only in titles (useful for finding specific functions/modules)\nmix usage_rules.search_docs \"Enum.zip\" --query-by title\n```\n\n\n<!-- usage_rules-end -->\n<!-- usage_rules:elixir-start -->\n## usage_rules:elixir usage\n# Elixir Core Usage Rules\n\n## Pattern Matching\n- Use pattern matching over conditional logic when possible\n- Prefer to match on function heads instead of using `if`/`else` or `case` in function bodies\n- `%{}` matches ANY map, not just empty maps. Use `map_size(map) == 0` guard to check for truly empty maps\n\n## Error Handling\n- Use `{:ok, result}` and `{:error, reason}` tuples for operations that can fail\n- Avoid raising exceptions for control flow\n- Use `with` for chaining operations that return `{:ok, _}` or `{:error, _}`\n\n## Common Mistakes to Avoid\n- Elixir has no `return` statement, nor early returns. The last expression in a block is always returned.\n- Don't use `Enum` functions on large collections when `Stream` is more appropriate\n- Avoid nested `case` statements - refactor to a single `case`, `with` or separate functions\n- Don't use `String.to_atom/1` on user input (memory leak risk)\n- Lists and enumerables cannot be indexed with brackets. Use pattern matching or `Enum` functions\n- Prefer `Enum` functions like `Enum.reduce` over recursion\n- When recursion is necessary, prefer to use pattern matching in function heads for base case detection\n- Using the process dictionary is typically a sign of unidiomatic code\n- Only use macros if explicitly requested\n- There are many useful standard library functions, prefer to use them where possible\n\n## Function Design\n- Use guard clauses: `when is_binary(name) and byte_size(name) > 0`\n- Prefer multiple function clauses over complex conditional logic\n- Name functions descriptively: `calculate_total_price/2` not `calc/2`\n- Predicate function names should not start with `is` and should end in a question mark.\n- Names like `is_thing` should be reserved for guards\n\n## Data Structures\n- Use structs over maps when the shape is known: `defstruct [:name, :age]`\n- Prefer keyword lists for options: `[timeout: 5000, retries: 3]`\n- Use maps for dynamic key-value data\n- Prefer to prepend to lists `[new | list]` not `list ++ [new]`\n\n## Mix Tasks\n\n- Use `mix help` to list available mix tasks\n- Use `mix help task_name` to get docs for an individual task\n- Read the docs and options fully before using tasks\n\n## Testing\n- Run tests in a specific file with `mix test test/my_test.exs` and a specific test with the line number `mix test path/to/test.exs:123`\n- Limit the number of failed tests with `mix test --max-failures n`\n- Use `@tag` to tag specific tests, and `mix test --only tag` to run only those tests\n- Use `assert_raise` for testing expected exceptions: `assert_raise ArgumentError, fn -> invalid_function() end`\n- Use `mix help test` to for full documentation on running tests\n\n## Debugging\n\n- Use `dbg/1` to print values while debugging. This will display the formatted value and other relevant information in the console.\n\n<!-- usage_rules:elixir-end -->\n<!-- usage_rules:otp-start -->\n## usage_rules:otp usage\n# OTP Usage Rules\n\n## GenServer Best Practices\n- Keep state simple and serializable\n- Handle all expected messages explicitly\n- Use `handle_continue/2` for post-init work\n- Implement proper cleanup in `terminate/2` when necessary\n\n## Process Communication\n- Use `GenServer.call/3` for synchronous requests expecting replies\n- Use `GenServer.cast/2` for fire-and-forget messages.\n- When in doubt, use `call` over `cast`, to ensure back-pressure\n- Set appropriate timeouts for `call/3` operations\n\n## Fault Tolerance\n- Set up processes such that they can handle crashing and being restarted by supervisors\n- Use `:max_restarts` and `:max_seconds` to prevent restart loops\n\n## Task and Async\n- Use `Task.Supervisor` for better fault tolerance\n- Handle task failures with `Task.yield/2` or `Task.shutdown/2`\n- Set appropriate task timeouts\n- Use `Task.async_stream/3` for concurrent enumeration with back-pressure\n\n<!-- usage_rules:otp-end -->\n<!-- ash_oban-start -->\n## ash_oban usage\n_The extension for integrating Ash resources with Oban._\n\n[ash_oban usage rules](deps/ash_oban/usage-rules.md)\n<!-- ash_oban-end -->\n<!-- ash_ai-start -->\n## ash_ai usage\n_Integrated LLM features for your Ash application._\n\n[ash_ai usage rules](deps/ash_ai/usage-rules.md)\n<!-- ash_ai-end -->\n<!-- igniter-start -->\n## igniter usage\n_A code generation and project patching framework_\n\n[igniter usage rules](deps/igniter/usage-rules.md)\n<!-- igniter-end -->\n<!-- ash_postgres-start -->\n## ash_postgres usage\n_The PostgreSQL data layer for Ash Framework_\n\n[ash_postgres usage rules](deps/ash_postgres/usage-rules.md)\n<!-- ash_postgres-end -->\n<!-- usage-rules-end -->\n",
    "purpose": "Library-specific patterns (Ash, Phoenix, Ecto, LiveView, etc.)"
  },
  "version": "2.0.0",
  "workflow": {
    "1_start_session": "Read this file (startup.json) - everything bundled here",
    "2_init_tracking": "mix bundles.track init maestro <branch> bootstrap",
    "3_check_task": "Read current_task.json for assigned work",
    "4_load_contextual": "If task involves another project, read their README. If task type known, load relevant bundle",
    "5_work": "Execute task, logging guideline usage as you go",
    "6_end_session": "mix bundles.track summary && mix session.capacity <used> 200000 && mix startup.build"
  }
}